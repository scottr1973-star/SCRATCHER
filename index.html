<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=10, maximum-scale=10, user-scalable=yes" />
  <title>Scratcher - Pro Turntable Controller</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;600;900&display=swap');

    :root{
      --bg-dark:#0F172A;
      --deck-bg:#1E293B;
      --mixer-color:#334155;
      --fader-rail:#475569;
      --accent:#38BDF8;
      --accent-glow:0 0 8px rgba(56,189,248,.6);
      --record-surface:#020617;
      --control-label:#94A3B8;
      --shadow-dark:#000;
      --box-shadow-raised:10px 10px 20px var(--shadow-dark), -5px -5px 10px #243445;
      --box-shadow-inset:inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px #243445;
    }

    html, body { height:100%; }
    body{
      margin:0;
      background:var(--bg-dark);
      color:#E2E8F0;
      font-family:'Inter', sans-serif;
      overflow:hidden;
      display:flex; align-items:center; justify-content:center;
      touch-action:auto;
    }

    #app-scale-shell{ position:relative; transform-origin:top left; will-change:transform,width,height; }

    .dj-container{
      width:1200px; max-width:1200px; min-width:1200px;
      display:flex; flex-direction:column;
      padding:8px;
      background:linear-gradient(145deg,#101824,#0d131f);
      border-radius:20px;
      box-shadow:0 20px 60px rgba(0,0,0,.9), 0 0 1px #1E293B;
      border:1px solid #1E293B;
      overflow:visible;
    }

    .main-mix{ display:flex; flex-grow:1; min-height:0; }
    .app-title{ font-family:'Orbitron', sans-serif; color:#fff; font-size:1.5rem; font-weight:700; }
    .fader-label, .status-info{ color:var(--control-label); font-size:10px; font-weight:600; text-transform:uppercase; letter-spacing:.5px; }

    #fileLoader{
      display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap;
      padding:4px 16px; margin-bottom:0;
      background:var(--mixer-color); border-radius:12px;
      box-shadow:inset 0 0 10px rgba(0,0,0,.5); border:1px solid #475569;
    }
    .file-loader-group{ display:flex; align-items:center; gap:10px; }
    #loadingStatus{ order:3; width:100%; margin-top:5px; text-align:right; white-space:pre-line; }

    .track-display-window{
      width:100%; height:30px; margin-bottom:5px; padding:4px 6px;
      background:#020617; border:3px solid var(--accent); border-radius:6px;
      display:flex; align-items:center; justify-content:center;
      color:#38BDF8; font-family:'Orbitron', monospace; font-size:13px;
      box-shadow:var(--accent-glow), inset 0 0 15px rgba(0,0,0,.8);
    }

    .track-select{
      width:100%;
      background:#475569; color:#111827; border:none; border-radius:8px;
      padding:8px 30px 8px 10px; font-size:12px; font-weight:900; text-align:left;
      -webkit-appearance:none; -moz-appearance:none; appearance:none;
      background-image:url('data:image/svg+xml;charset=US-ASCII,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22292.4%22 height=%22292.4%22%3E%3Cpath fill=%22%23111827%22 d=%22M287 69.4a17.6 17.6 0 0 0-13.6-6.4H19a17.6 17.6 0 0 0-13.6 6.4 17.6 17.6 0 0 0 0 24.3l127.3 127.9c5.6 5.6 13.3 8.2 21.3 8.2s15.7-2.6 21.3-8.2L287 93.7a17.9 17.9 0 0 0 0-24.3z%22/%3E%3C/svg%3E');
      background-repeat:no-repeat; background-position:right 10px center; background-size:10px auto;
    }
    .track-select option{ color:#fff; background:#1E293B; }

    .turntable{
      padding:15px; background:var(--deck-bg); border-radius:12px;
      box-shadow:var(--box-shadow-raised), inset 0 0 15px rgba(0,0,0,.3);
      margin:0 8px; flex-grow:1; display:flex; flex-direction:column;
    }
    .mixer{
      padding:15px 10px; background:var(--mixer-color); margin:0 8px; border-radius:12px;
      box-shadow:var(--box-shadow-raised); display:flex; flex-direction:column; gap:5px;
    }
    .deck-controls{ flex-grow:1; display:flex; flex-direction:column; justify-content:space-around; }

    .record-plate{
      width:230px; height:230px; max-width:95%; max-height:95%;
      position:relative; align-self:center; margin-top:5px; margin-bottom:10px;
    }
    .record{
      position:absolute; inset:0; border-radius:50%; background:var(--record-surface);
      border:4px solid #475569; box-shadow:0 0 20px rgba(0,0,0,.9) inset, 0 8px 15px rgba(0,0,0,.6);
      cursor:grab; will-change:transform;
      touch-action:none;
    }
    .record-label{
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      width:30%; height:30%; border-radius:50%; background:#EF4444; color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-family:'Orbitron', sans-serif; font-size:1.5rem; font-weight:900;
      box-shadow:0 0 5px rgba(0,0,0,.5) inset;
    }
    .cue-mark{ position:absolute; top:5%; left:50%; transform:translateX(-50%); width:8%; height:8%; border-radius:50%; background:#FBBF24; }

    input[type="range"]{ box-shadow:var(--box-shadow-inset); height:15px; margin:0; padding:0; }
    input[type="range"]::-webkit-slider-thumb{
      box-shadow:0 3px 6px rgba(0,0,0,.8), 0 0 1px #fff, inset 1px 1px 3px rgba(255,255,255,.4);
      border:1px solid #fff;
    }

    .crossfader-rail{ position:relative; height:15px; background:var(--fader-rail); border-radius:8px; width:100%; margin-top:5px; box-shadow:var(--box-shadow-inset); }
    .crossfader-handle{
      position:absolute; top:-2px; width:30px; height:25px; background:#E2E8F0; border:1px solid #fff; border-radius:4px;
      cursor:grab; transition:left .05s ease-out;
      box-shadow:0 3px 6px rgba(0,0,0,.8), 0 0 1px #fff, inset 1px 1px 3px rgba(255,255,255,.4);
    }
    .crossfader-handle:active{ cursor:grabbing; box-shadow:inset 0 1px 3px rgba(0,0,0,.5); }

    .btn{
      padding:8px 12px; border-radius:6px; font-weight:900; color:#111827; text-transform:uppercase; font-size:11px;
      box-shadow:0 3px 5px rgba(0,0,0,.8); border:1px solid rgba(255,255,255,.1); transition:all .1s;
    }
    .play-btn{ background:#10B981; }
    .stop-btn{ background:#EF4444; }
    .cue-btn{ background:#FBBF24; }
    .btn:active{ box-shadow:inset 0 1px 5px rgba(0,0,0,.8); transform:translateY(1px); }
    .cue-btn.active{ background:#D97706; box-shadow:inset 0 1px 5px rgba(0,0,0,.8); transform:translateY(1px); }

    .controls-row{ display:flex; align-items:center; gap:8px; }
    .controls-row button{ flex-grow:1; }
    .status-light{ flex-shrink:0; margin-left:0; }

    .horizontal-fader-group{ display:flex; justify-content:space-between; align-items:flex-end; width:100%; margin-bottom:0; }
    .master-hp-fader-group{ display:flex; justify-content:space-around; align-items:center; width:100%; margin-bottom:0; }
    .fader-control-horizontal{ display:flex; flex-direction:column; align-items:center; width:30%; }
    .fader-control-horizontal input[type="range"]{ width:100%; margin-top:5px; }

    .master-controls-group{ display:flex; flex-direction:column; align-items:center; justify-content:flex-end; gap:5px; margin-bottom:0; }
    .vu-meter{ display:flex; flex-direction:column-reverse; width:15px; height:50px; background:#020617; border:1px solid #475569; border-radius:4px; padding:2px; }
    .vu-segment{ height:10%; margin-bottom:1px; background:#38BDF8; opacity:.2; transition:opacity .1s; }
    .vu-segment.on{ opacity:1; }
    .vu-segment.yellow{ background:#FACC15; }
    .vu-segment.red{ background:#EF4444; }
    .hp-mix-control{ width:100%; margin-top:0; display:flex; flex-direction:column; align-items:center; }
    .hp-mix-labels{ width:100%; display:flex; justify-content:space-between; font-size:8px; color:var(--control-label); margin-top:3px; }

    .fx-panel-top, .fx-panel{ margin-bottom:0; }
    .fx-control{ margin-top:5px; }
  </style>

  <!-- Stylus (triangle; fixed at ~3 o’clock, slightly lowered and nudged left) -->
  <style id="stylus-addon">
    .stylus-slider{
      position:absolute;
      top:calc(50% + 4px);
      right:-2px;            /* nudged left to sit at 3 o'clock */
      transform:translateY(-50%);
      height:20px;
      pointer-events:none;
      z-index:10;
    }
    .stylus-hitbox{
      position:absolute; top:-6px; width:24px; height:20px;
      pointer-events:auto; cursor:ew-resize;
    }
    .stylus-handle{
      position:absolute; left:0; top:0; width:0; height:0;
      border-left:8px solid transparent; border-right:8px solid transparent;
      border-bottom:12px solid #38BDF8;
      filter:drop-shadow(0 0 2px rgba(56,189,248,.6));
    }
  </style>
</head>
<body>
  <div id="app-scale-shell">
    <div class="dj-container">
      <div id="fileLoader">
        <h1 class="app-title">SCRATCHER</h1>
        <div class="file-loader-group">
          <label class="text-sm font-semibold text-sky-400">LOAD YOUR MUSIC FOLDERS:</label>
          <!-- Hidden inputs -->
          <input type="file" id="musicFiles" multiple webkitdirectory directory style="display:none;">
          <input type="file" id="filePicker" multiple
                 accept=".wav,.wave,.aif,.aiff,.mp3,.m4a,.aac,.flac,.ogg,.oga,.opus,audio/*"
                 style="display:none;">
          <button id="loadFilesBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-1 px-3 rounded text-xs transition">Select Folders</button>
        </div>
        <div id="loadingStatus" class="text-xs mt-2 text-gray-300 w-full text-right">0 files loaded.</div>
      </div>

      <div class="main-mix">
        <div class="turntable" id="deckA">
          <div class="eq-section">
            <div class="eq-knob"><label class="eq-label">LOW</label><input type="range" id="eqLowA" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label class="eq-label">MID</label><input type="range" id="eqMidA" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label class="eq-label">HIGH</label><input type="range" id="eqHighA" min="-12" max="12" step="0.1" value="0.0"></div>
          </div>

          <div class="track-display-window" id="statusA">---</div>

          <div class="record-plate">
            <div class="record" id="recordA">
              <div class="record-label">A</div>
              <div class="cue-mark"></div>
            </div>
          </div>

          <div class="deck-controls">
            <select class="track-select" id="trackSelectA"><option value="-1" disabled selected>SELECT TRACK</option></select>
            <div class="controls-row">
              <button class="btn play-btn" id="playA">PLAY</button>
              <button class="btn cue-btn" id="cueA">CUE</button>
              <button class="btn stop-btn" id="stopA">STOP</button>
              <div class="status-light" id="lightA"></div>
            </div>
            <label class="fader-label text-center">PITCH</label>
            <input type="range" id="pitchA" min="0.5" max="1.5" step="0.01" value="1.0">
          </div>
        </div>

        <div class="mixer">
          <div class="horizontal-fader-group">
            <div class="fader-control-horizontal">
              <label class="fader-label">VOL A</label>
              <input type="range" id="volA" min="0" max="1" step="0.01" value="0.7">
            </div>

            <div class="master-controls-group">
              <label class="fader-label">OUTPUT</label>
              <div class="vu-meter" id="masterVUMeter">
                <div class="vu-segment" style="height:10%" data-level="1"></div>
                <div class="vu-segment" style="height:10%" data-level="2"></div>
                <div class="vu-segment" style="height:10%" data-level="3"></div>
                <div class="vu-segment" style="height:10%" data-level="4"></div>
                <div class="vu-segment" style="height:10%" data-level="5"></div>
                <div class="vu-segment" style="height:10%" data-level="6"></div>
                <div class="vu-segment yellow" style="height:10%" data-level="7"></div>
                <div class="vu-segment yellow" style="height:10%" data-level="8"></div>
                <div class="vu-segment red" style="height:10%" data-level="9"></div>
                <div class="vu-segment red" style="height:10%" data-level="10"></div>
              </div>
            </div>

            <div class="fader-control-horizontal">
              <label class="fader-label">VOL B</label>
              <input type="range" id="volB" min="0" max="1" step="0.01" value="0.7">
            </div>
          </div>

          <div class="master-hp-fader-group">
            <div class="fader-control-horizontal" style="width:45%;">
              <label class="fader-label">MASTER VOL</label>
              <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.9">
            </div>
            <div class="fader-control-horizontal" style="width:45%;">
              <label class="fader-label">HP VOL</label>
              <input type="range" id="hpVol" min="0" max="1" step="0.01" value="0.8">
            </div>
          </div>

          <div class="hp-mix-control">
            <label class="fader-label text-xs">HP CUE / MASTER</label>
            <input type="range" id="hpMix" min="0" max="1" step="0.01" value="0.5" title="Headphone Cue/Master Mix">
            <div class="hp-mix-labels"><span>CUE</span><span>MASTER</span></div>
          </div>

          <div class="fx-panel-top">
            <label class="fader-label text-xs">EFFECTS WET/DRY</label>
            <div class="fx-control">
              <input type="range" id="reverbWetDry" min="0" max="1" step="0.01" value="0.0" title="Reverb Wet/Dry">
              <label class="fader-label text-xs">REVERB</label>
            </div>
            <div class="fx-control">
              <input type="range" id="delayWetDry" min="0" max="1" step="0.01" value="0.0" title="Delay Wet/Dry">
              <label class="fader-label text-xs">DELAY</label>
            </div>
          </div>

          <div class="fx-panel">
            <label class="fader-label text-xs">MASTER CHAIN</label>
            <div class="fx-control">
              <input type="range" id="masterFilterFreq" min="100" max="18000" step="10" value="18000" title="Low Pass Filter Frequency">
              <label class="fader-label text-xs">FILTER (LPF)</label>
            </div>
            <div class="fx-control">
              <input type="range" id="delayFeedback" min="0.1" max="0.9" step="0.01" value="0.3" title="Delay Feedback">
              <label class="fader-label text-xs">FEEDBACK</label>
            </div>
            <div class="fx-control">
              <input type="range" id="delayTime" min="0.05" max="0.5" step="0.01" value="0.3" title="Delay Time">
              <label class="fader-label text-xs">TIME</label>
            </div>
          </div>

          <div class="crossfader-rail" id="crossfaderRail"><div class="crossfader-handle" id="crossfaderHandle"></div></div>
          <label class="fader-label">X-FADER</label>
        </div>

        <div class="turntable" id="deckB">
          <div class="eq-section">
            <div class="eq-knob"><label class="eq-label">LOW</label><input type="range" id="eqLowB" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label class="eq-label">MID</label><input type="range" id="eqMidB" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label class="eq-label">HIGH</label><input type="range" id="eqHighB" min="-12" max="12" step="0.1" value="0.0"></div>
          </div>

          <div class="track-display-window" id="statusB">---</div>

          <div class="record-plate">
            <div class="record" id="recordB">
              <div class="record-label">B</div>
              <div class="cue-mark"></div>
            </div>
          </div>

          <div class="deck-controls">
            <select class="track-select" id="trackSelectB"><option value="-1" disabled selected>SELECT TRACK</option></select>
            <div class="controls-row">
              <button class="btn play-btn" id="playB">PLAY</button>
              <button class="btn cue-btn" id="cueB">CUE</button>
              <button class="btn stop-btn" id="stopB">STOP</button>
              <div class="status-light" id="lightB"></div>
            </div>
            <label class="fader-label text-center">PITCH</label>
            <input type="range" id="pitchB" min="0.5" max="1.5" step="0.01" value="1.0">
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* --------- Audio/Deck plumbing --------- */
    let TRACKS = [];
    let audioCtx;
    let animationFrameId;
    let crossfaderGainA, crossfaderGainB, masterFilter, delayNode, feedbackGain, delayWetGain, reverbWetGain, reverbDelay, reverbLowPass, cueGain, masterOutGain;
    let masterVolGain;
    let masterPreListen;
    let analyserNode;

    const DECK_A = { id:'A', trackIndex:-1, buffer:null, source:null, gain:null, rate:1.0, isPlaying:false, playbackPos:0, lastUpdateTime:0, currentRotation:0, _rotLast:0, eq:{low:null,mid:null,high:null,scratch:null}, hasMoved:false, isDragging:false, startAngle:0, baseRotation:0, accumAngle:0, startPlaybackPos:0, manualRotate:false, rateNode:null };
    const DECK_B = { id:'B', trackIndex:-1, buffer:null, source:null, gain:null, rate:1.0, isPlaying:false, playbackPos:0, lastUpdateTime:0, currentRotation:0, _rotLast:0, eq:{low:null,mid:null,high:null,scratch:null}, hasMoved:false, isDragging:false, startAngle:0, baseRotation:0, accumAngle:0, startPlaybackPos:0, manualRotate:false, rateNode:null };

    const $ = id => document.getElementById(id);
    const decks = {
      A:{ state:DECK_A, recordEl:$('recordA'), trackSelectEl:$('trackSelectA'), playBtn:$('playA'), stopBtn:$('stopA'), cueBtn:$('cueA'), light:$('lightA'), status:$('statusA'), pitch:$('pitchA'), vol:$('volA'), eqLow:$('eqLowA'), eqMid:$('eqMidA'), eqHigh:$('eqHighA') },
      B:{ state:DECK_B, recordEl:$('recordB'), trackSelectEl:$('trackSelectB'), playBtn:$('playB'), stopBtn:$('stopB'), cueBtn:$('cueB'), light:$('lightB'), status:$('statusB'), pitch:$('pitchB'), vol:$('volB'), eqLow:$('eqLowB'), eqMid:$('eqMidB'), eqHigh:$('eqHighB') },
    };
    window.decks = decks;

    const crossfaderHandle = $('crossfaderHandle');
    const crossfaderRail   = $('crossfaderRail');
    const delayWetDryControl = $('delayWetDry');
    const reverbWetDryControl = $('reverbWetDry');
    const delayFeedbackControl = $('delayFeedback');
    const delayTimeActualControl = $('delayTime');
    const masterFilterFreq = $('masterFilterFreq');
    const hpVolControl = $('hpVol');
    const musicFilesInput = $('musicFiles');
    const filePicker      = $('filePicker');
    const loadFilesBtn    = $('loadFilesBtn');
    const loadingStatus   = $('loadingStatus');
    const masterVolControl = $('masterVol');
    const masterVUMeter = $('masterVUMeter');
    const hpMixControl = $('hpMix');
    const vuSegments = Array.from(masterVUMeter.querySelectorAll('.vu-segment'));

    const BLANK_DISPLAY_TEXT = '---';
    const RECORD_PADDING_PERCENT = 0.1;
    const SECS_PER_REV = 60/33.333; // ≈1.8s per full revolution

    function initAudio(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // HP chain (kept for completeness; CUE no longer mutes the deck)
      cueGain = audioCtx.createGain();
      cueGain.gain.value = parseFloat(hpVolControl.value);
      cueGain.connect(audioCtx.destination);

      masterPreListen = audioCtx.createGain();
      updateHPMix(parseFloat(hpMixControl.value));
      masterPreListen.connect(cueGain);

      masterOutGain = audioCtx.createGain();
      masterOutGain.gain.value = 1.0;

      masterVolGain = audioCtx.createGain();
      masterVolGain.gain.value = parseFloat(masterVolControl.value);

      masterFilter = audioCtx.createBiquadFilter();
      masterFilter.type = 'lowpass';
      masterFilter.frequency.value = parseFloat(masterFilterFreq.value);
      masterFilter.Q.value = .5;

      delayNode = audioCtx.createDelay(1.0);
      delayNode.delayTime.value = parseFloat(delayTimeActualControl.value);

      feedbackGain = audioCtx.createGain();
      feedbackGain.gain.value = parseFloat(delayFeedbackControl.value);

      delayWetGain = audioCtx.createGain();
      delayWetGain.gain.value = parseFloat(delayWetDryControl.value);

      reverbLowPass = audioCtx.createBiquadFilter();
      reverbLowPass.type = 'lowpass';
      reverbLowPass.frequency.value = 4000;
      reverbLowPass.Q.value = .5;

      reverbDelay = audioCtx.createDelay(.3);
      reverbDelay.delayTime.value = .05;

      reverbWetGain = audioCtx.createGain();
      reverbWetGain.gain.value = parseFloat(reverbWetDryControl.value);

      // FX
      delayNode.connect(feedbackGain);
      feedbackGain.connect(delayNode);
      delayNode.connect(delayWetGain);

      masterFilter.connect(reverbDelay);
      reverbDelay.connect(reverbLowPass);
      reverbLowPass.connect(reverbWetGain);

      // Master
      masterOutGain.connect(delayNode);
      masterOutGain.connect(masterFilter);

      masterFilter.connect(masterVolGain);
      delayWetGain.connect(masterVolGain);
      reverbWetGain.connect(masterVolGain);

      masterVolGain.connect(audioCtx.destination);
      masterVolGain.connect(masterPreListen);

      analyserNode = audioCtx.createAnalyser();
      analyserNode.fftSize = 256;
      masterVolGain.connect(analyserNode);

      crossfaderGainA = audioCtx.createGain();
      crossfaderGainB = audioCtx.createGain();

      initDeckAudio(DECK_A, crossfaderGainA);
      initDeckAudio(DECK_B, crossfaderGainB);

      crossfaderGainA.connect(masterOutGain);
      crossfaderGainB.connect(masterOutGain);

      updateCrossfader(.5);

      requestAnimationFrame(update);
    }

    function initDeckAudio(deckState, crossfaderGain){
      deckState.gain = audioCtx.createGain();
      deckState.gain.gain.value = parseFloat($('vol'+deckState.id).value);
      deckState.gain.connect(crossfaderGain);

      // (Optional HP path kept, not used by CUE anymore)
      deckState.cueNode = audioCtx.createGain();
      deckState.cueNode.gain.value = 0.0;
      deckState.cueNode.connect(masterPreListen);

      const eqLow  = audioCtx.createBiquadFilter();  eqLow.type='lowshelf';  eqLow.frequency.value=320;  eqLow.gain.value=parseFloat($('eqLow'+deckState.id).value);
      const eqMid  = audioCtx.createBiquadFilter();  eqMid.type='peaking';   eqMid.frequency.value=1000; eqMid.Q.value=1.0; eqMid.gain.value=parseFloat($('eqMid'+deckState.id).value);
      const eqHigh = audioCtx.createBiquadFilter();  eqHigh.type='highshelf';eqHigh.frequency.value=3200; eqHigh.gain.value=parseFloat($('eqHigh'+deckState.id).value);

      const scratchFilter = audioCtx.createBiquadFilter();
      scratchFilter.type='highpass'; scratchFilter.frequency.value=20; scratchFilter.Q.value=1.0;

      deckState.eq = { low:eqLow, mid:eqMid, high:eqHigh, scratch:scratchFilter };

      eqLow.connect(eqMid); eqMid.connect(eqHigh); eqHigh.connect(scratchFilter);
      scratchFilter.connect(deckState.gain);
      scratchFilter.connect(deckState.cueNode);
    }

    function populateTrackSelects(){
      const A = decks.A.trackSelectEl, B = decks.B.trackSelectEl;
      [A,B].forEach(sel => {
        sel.innerHTML = '<option value="-1" disabled selected>SELECT TRACK</option>';
        TRACKS.forEach((t, i) => {
          const opt = document.createElement('option');
          opt.value = i; opt.textContent = t.fileName; sel.appendChild(opt);
        });
      });
    }

    function loadDeck(deckId, idx){
      const deck = decks[deckId], st = deck.state;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      if (idx === -1 || idx >= TRACKS.length){ st.trackIndex=-1; st.buffer=null; deck.status.textContent=BLANK_DISPLAY_TEXT; deck.light.classList.remove('active'); return; }
      const track = TRACKS[idx];
      st.trackIndex=idx; st.buffer=track.buffer; st.playbackPos=0; st.currentRotation=0; st.baseRotation=0; st.accumAngle=0;
      deck.status.textContent = track.fileName.substring(0, 30);
      deck.light.classList.remove('active');
      updatePitch(deckId, parseFloat(deck.pitch.value));
    }

    function playDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      if (!st.buffer) return;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }

      const src = audioCtx.createBufferSource();
      src.buffer = st.buffer; src.connect(st.eq.low);
      src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;

      st.source = src; st.isPlaying = true; st.lastUpdateTime = audioCtx.currentTime; st._rotLast = 0;
      src.start(0, st.playbackPos);
      deck.light.classList.add('active');

      src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
    }
    window.playDeck = playDeck;

    function stopDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      st.isPlaying=false;
      deck.light.classList.remove('active');
    }
    window.stopDeck = stopDeck;

    // CUE now: restart from 0 and play on MASTER; does NOT mute deck
    function cueDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      if (!st.buffer) return;

      // Toggle button state only (no routing changes)
      const active = deck.cueBtn.classList.toggle('active');

      st.playbackPos = 0;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }

      const src = audioCtx.createBufferSource();
      src.buffer=st.buffer; src.connect(st.eq.low);
      src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;
      st.source=src; st.isPlaying=true; st.lastUpdateTime=audioCtx.currentTime; st._rotLast=0;
      src.start(0, st.playbackPos);
      deck.light.classList.add('active');

      src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
    }

    function updateDeckTime(st){
      if (!st.isPlaying || !st.buffer) return;
      const dt = audioCtx.currentTime - st.lastUpdateTime;
      st.lastUpdateTime = audioCtx.currentTime;
      const rate = st.rateNode ? st.rateNode.value : 1.0;
      st.playbackPos = (st.playbackPos + dt * rate);
      if (st.playbackPos >= st.buffer.duration){
        st.playbackPos = st.buffer.duration;
        st.isPlaying = false;
      }
      if (st.playbackPos < 0) st.playbackPos = 0;
    }

    function updatePitch(deckId, v){ const st = decks[deckId].state; st.rate = v; if (st.source && st.rateNode) st.rateNode.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateVolume(deckId, v){ const st = decks[deckId].state; st.gain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateEQ(deckId, type, v){ const st = decks[deckId].state; st.eq[type].gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateMasterVol(v){ masterVolGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateHPMix(v){ masterPreListen.gain.value = v; } // still functional but CUE no longer depends on it

    function updateCrossfader(value){
      const aGain = Math.cos(value * 0.5 * Math.PI);
      const bGain = Math.cos((1.0 - value) * 0.5 * Math.PI);
      crossfaderGainA.gain.value = aGain;
      crossfaderGainB.gain.value = bGain;
    }
    function updateFilterFreq(v){ masterFilter.frequency.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateDelayFeedback(v){ feedbackGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateDelayTime(v){ delayNode.delayTime.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateFXWetDry(fx, v){ if (fx==='delay') delayWetGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); else if (fx==='reverb') reverbWetGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }

    function updateVUMeter(){
      if (!analyserNode) return;
      const N = analyserNode.frequencyBinCount, data = new Uint8Array(N);
      analyserNode.getByteFrequencyData(data);
      let sum = 0; for (let i=0;i<N;i++){ sum += data[i]*i; }
      const norm = Math.min(10, Math.max(0, Math.ceil(sum / (N * 100))));
      vuSegments.forEach((seg, idx) => seg.classList.toggle('on', (10-idx) <= norm));
    }

    function update(){
      updateDeckTime(DECK_A); updateDeckTime(DECK_B);
      updateRecordRotation(DECK_A); updateRecordRotation(DECK_B);
      updateVUMeter();
      animationFrameId = requestAnimationFrame(update);
    }

    function updateRecordRotation(st){
      if (!st.buffer) return;
      if (st.isDragging || st.manualRotate) return;
      const now = performance.now() * 0.001;
      if (!st._rotLast) st._rotLast = now;
      const dt = now - st._rotLast;
      st._rotLast = now;

      let rate = 0;
      if (st.isPlaying) rate = st.rateNode ? st.rateNode.value : 1.0;

      if (rate !== 0){
        const rotationSpeedDegPerSec = rate * 360;
        st.currentRotation = (st.currentRotation + rotationSpeedDegPerSec * dt);
        const deck = decks[st.id];
        if (deck && deck.recordEl){
          deck.recordEl.style.transform = `rotate(${st.currentRotation}deg)`;
        }
      }
    }

    function pointerAngleDeg(el, clientX, clientY){
      const rect = el.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top  + rect.height/2;
      const dx = clientX - cx;
      const dy = clientY - cy;
      return Math.atan2(dy, dx) * 180/Math.PI;
    }
    function shortestDelta(a, b){
      let d = b - a;
      while (d > 180) d -= 360;
      while (d < -180) d += 360;
      return d;
    }

    function jumpToPosition(deckId, e){
      const deck = decks[deckId], st = deck.state, recordEl = deck.recordEl;
      if (!st.buffer) return;

      const rect = recordEl.getBoundingClientRect();
      const centerX = rect.left + rect.width/2;
      const centerY = rect.top + rect.height/2;
      const radius  = rect.width/2;

      const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
      const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0] ? e.touches[0].clientY : e.clientY : e.clientY);

      const dx = clientX - centerX, dy = clientY - centerY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      let normalized = distance / radius;

      const P = RECORD_PADDING_PERCENT;
      let t = (normalized - P) / (1 - 2*P);
      t = Math.max(0, Math.min(1, t));

      const newPos = t * st.buffer.duration;
      st.playbackPos = newPos;

      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }

      const src = audioCtx.createBufferSource();
      src.buffer = st.buffer; src.connect(st.eq.low);
      src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;

      st.source = src; st.isPlaying = true; st.lastUpdateTime = audioCtx.currentTime; st._rotLast = 0;
      src.start(0, st.playbackPos);
      deck.light.classList.add('active');
      src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
    }

    let activeDeck = null;

    function handleStart(e, deckId){
      if (e.touches && e.touches.length > 1) return;
      e.preventDefault();
      initAudio();
      audioCtx.resume && audioCtx.resume();

      const deck = decks[deckId], st = deck.state, el = deck.recordEl;
      if (!st.buffer) return;

      st.isDragging = true; st.manualRotate = true; activeDeck = deck; st.hasMoved=false;

      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      st.isPlaying = false;
      deck.light.classList.remove('active');

      const cx = (e.clientX != null) ? e.clientX : e.touches[0].clientX;
      const cy = (e.clientY != null) ? e.clientY : e.touches[0].clientY;

      st.startAngle = pointerAngleDeg(el, cx, cy);
      st.baseRotation = st.currentRotation;
      st.accumAngle = 0;
      st.startPlaybackPos = st.playbackPos;
    }

    function handleMove(e){
      if (e.touches && e.touches.length > 1) return;
      if (!activeDeck || !activeDeck.state.isDragging) return;
      e.preventDefault();

      const deck = activeDeck, st = deck.state, el = deck.recordEl;
      const cx = (e.clientX != null) ? e.clientX : (e.touches && e.touches.length ? e.touches[0].clientX : null);
      const cy = (e.clientY != null) ? e.clientY : (e.touches && e.touches.length ? e.touches[0].clientY : null);
      if (cx === null || cy === null) return;

      st.hasMoved = true;

      const nowAngle = pointerAngleDeg(el, cx, cy);
      st.accumAngle += shortestDelta(st.startAngle, nowAngle);
      st.startAngle = nowAngle;

      st.currentRotation = st.baseRotation + st.accumAngle;
      el.style.transform = `rotate(${st.currentRotation}deg)`;

      const dSecs = (st.accumAngle / 360) * SECS_PER_REV;
      st.playbackPos = Math.max(0, Math.min((st.startPlaybackPos + dSecs), st.buffer.duration));
    }

    function handleEnd(deckId){
      const deck = decks[deckId], st = deck.state;
      if (!st.isDragging) return;

      st.isDragging=false; st.manualRotate=false;

      if (st.buffer){
        if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
        const src = audioCtx.createBufferSource();
        src.buffer=st.buffer; src.connect(st.eq.low);
        src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;

        st.source=src; st.isPlaying=true; st.lastUpdateTime=audioCtx.currentTime; st._rotLast=0;
        src.start(0, st.playbackPos);
        deck.light.classList.add('active');

        src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
      }
    }

    const bindDeck = (deckId)=>{
      const d = decks[deckId];
      d.trackSelectEl.addEventListener('change', (e) => loadDeck(deckId, parseInt(e.target.value)));
      d.playBtn.addEventListener('click', () => { initAudio(); audioCtx.resume && audioCtx.resume(); playDeck(deckId); });
      d.stopBtn.addEventListener('click', () => stopDeck(deckId));
      d.cueBtn.addEventListener('click', () => { initAudio(); audioCtx.resume && audioCtx.resume(); cueDeck(deckId); });
      d.pitch.addEventListener('input', (e) => updatePitch(deckId, parseFloat(e.target.value)));
      d.vol.addEventListener('input',   (e) => updateVolume(deckId, parseFloat(e.target.value)));
      d.eqLow.addEventListener('input', (e) => updateEQ(deckId,'low', parseFloat(e.target.value)));
      d.eqMid.addEventListener('input', (e) => updateEQ(deckId,'mid', parseFloat(e.target.value)));
      d.eqHigh.addEventListener('input',(e) => updateEQ(deckId,'high',parseFloat(e.target.value)));

      const el = d.recordEl;
      el.addEventListener('mousedown', (e)=>handleStart(e, deckId));
      el.addEventListener('touchstart',(e)=>handleStart(e, deckId), {passive:false});
      el.addEventListener('click', (e)=>{ if (!decks[deckId].state.hasMoved) jumpToPosition(deckId, e); });
    };
    bindDeck('A'); bindDeck('B');

    document.addEventListener('mousemove', handleMove);
    document.addEventListener('touchmove', handleMove, {passive:false});
    document.addEventListener('mouseup', ()=>{ if (activeDeck) handleEnd(activeDeck.state.id); });
    document.addEventListener('touchend',()=>{ if (activeDeck) handleEnd(activeDeck.state.id); });

    document.body.addEventListener('click', ()=>{ initAudio(); audioCtx.resume && audioCtx.resume(); }, {once:true});
    document.body.addEventListener('touchstart', ()=>{ initAudio(); audioCtx.resume && audioCtx.resume(); }, {once:true});

    /* --------- SCALE ENGINE (fit-to-window) --------- */
    (function(){
      const SHELL = document.getElementById('app-scale-shell');
      const APP   = document.querySelector('.dj-container');
      const BASE_W = 1200;

      function applyScale(){
        SHELL.style.transform = 'scale(1)';
        APP.style.width = BASE_W + 'px';

        const baseH = APP.getBoundingClientRect().height;
        const s = Math.min(window.innerWidth / BASE_W, window.innerHeight / baseH);

        SHELL.style.transform = `scale(${s})`;
        SHELL.style.width  = (BASE_W * s) + 'px';
        SHELL.style.height = (baseH  * s) + 'px';
      }

      window.addEventListener('resize', applyScale);
      window.addEventListener('orientationchange', applyScale);
      document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(applyScale, 0); });
    })();

    /* ---------------- File/Folder loading ---------------- */
    function isMobileDevice(){
      const ua = navigator.userAgent || '';
      const uad = (navigator.userAgentData && navigator.userAgentData.mobile) ? true : false;
      return /Android|iPhone|iPad|iPod/i.test(ua) || uad;
    }

    loadFilesBtn.addEventListener('click', async () => {
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}

      const mobile = isMobileDevice();

      if (!mobile && 'showDirectoryPicker' in window) {
        try { await pickDirectoryWithFSAccess(); return; }
        catch (err) {
          if (err && (err.name === 'AbortError' || err.code === 20)) { loadingStatus.textContent = 'Selection cancelled.'; return; }
        }
      }

      if (!mobile && ('webkitdirectory' in musicFilesInput)) {
        musicFilesInput.value = '';
        musicFilesInput.click();
        return;
      }

      if ('showOpenFilePicker' in window) {
        try {
          const handles = await window.showOpenFilePicker({
            multiple: true,
            types: [{ description: 'Audio', accept: { 'audio/*': ['.wav','.wave','.aif','.aiff','.mp3','.m4a','.aac','.flac','.ogg','.oga','.opus'] } }]
          });
          const files = await Promise.all(handles.map(h => h.getFile()));
          await loadFilesFromArray(files.filter(isAudioFile));
          return;
        } catch (err) {
          if (err && (err.name === 'AbortError' || err.code === 20)) { loadingStatus.textContent = 'Selection cancelled.'; return; }
        }
      }

      filePicker.value = '';
      filePicker.click();
    });

    musicFilesInput.addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files.length) { loadingStatus.textContent = 'No files selected.'; return; }
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      await loadFilesFromFileList(e.target.files);
    });
    filePicker.addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files.length) { loadingStatus.textContent = 'No files selected.'; return; }
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      await loadFilesFromFileList(e.target.files);
    });

    async function pickDirectoryWithFSAccess() {
      const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
      const files = [];
      await collectFilesRecursive(dirHandle, files);
      await loadFilesFromArray(files);
    }
    async function collectFilesRecursive(dirHandle, outArr, pathPrefix = '') {
      for await (const [name, handle] of dirHandle.entries()) {
        const relPath = pathPrefix ? `${pathPrefix}/${name}` : name;
        if (handle.kind === 'file') {
          const file = await handle.getFile();
          file._relPath = relPath;
          if (isAudioFile(file)) outArr.push(file);
        } else if (handle.kind === 'directory') {
          await collectFilesRecursive(handle, outArr, relPath);
        }
      }
    }

    async function loadFilesFromFileList(fileList) {
      const files = Array.from(fileList).filter(isAudioFile);
      await loadFilesFromArray(files);
    }

    async function decodeWithBestSafariCompat(buf){
      try { await audioCtx.resume(); } catch(e){}
      try {
        if (audioCtx.decodeAudioData.length === 1) {
          return await audioCtx.decodeAudioData(buf);
        }
      } catch(e) { /* fall back */ }
      return await new Promise((resolve, reject) => {
        try { audioCtx.decodeAudioData(buf.slice(0), resolve, reject); }
        catch(err){ reject(err); }
      });
    }

    async function loadFilesFromArray(files) {
      if (!files.length) { loadingStatus.textContent = 'No audio files found.'; return; }
      if (!audioCtx) initAudio();

      TRACKS = [];
      let loaded = 0, failed = 0;
      loadingStatus.textContent = 'Loading...';

      for (const file of files) {
        try {
          const buf = await file.arrayBuffer();
          const decoded = await decodeWithBestSafariCompat(buf);
          TRACKS.push({ fileName: file.name, buffer: decoded });
          loaded++;
          loadingStatus.textContent = `${loaded} loaded` + (failed?`, ${failed} failed`:'');
        } catch (err) {
          failed++;
          loadingStatus.textContent = `${loaded} loaded, ${failed} failed`;
        }
      }

      if (loaded > 0) {
        populateTrackSelects();

        const aIdx = 0;
        const bIdx = (TRACKS.length > 1) ? 1 : 0;
        decks.A.trackSelectEl.value = String(aIdx);
        decks.B.trackSelectEl.value = String(bIdx);
        loadDeck('A', aIdx);
        loadDeck('B', bIdx);
      }

      if (!loaded && failed) {
        loadingStatus.textContent += ' (could not decode on this device).';
      }
    }

    function isAudioFile(file) {
      if (!file) return false;
      const name = (file.name || '').toLowerCase();
      const extOkay = /\.(wav|wave|aif|aiff|mp3|m4a|aac|flac|ogg|oga|opus)$/.test(name);
      const typeOkay = (file.type && file.type.toLowerCase().startsWith('audio/'));
      return extOkay || typeOkay;
    }

    /* -------- Crossfader (scale-aware) -------- */
    let isDraggingX = false;
    const HANDLE_HALF = 15;
    function setCrossfaderUI(value){
      const railCSSWidth = crossfaderRail.offsetWidth;
      const leftCSS = value * railCSSWidth - HANDLE_HALF;
      crossfaderHandle.style.left = `${leftCSS}px`;
    }
    window.addEventListener('load', ()=> setCrossfaderUI(.5));

    crossfaderHandle.addEventListener('mousedown', (e)=>{ e.preventDefault(); isDraggingX=true; });
    document.addEventListener('mouseup',  ()=>{ isDraggingX=false; });
    document.addEventListener('mousemove',(e)=>{
      if (!isDraggingX) return;
      const rect = crossfaderRail.getBoundingClientRect();
      const railCSSWidth = crossfaderRail.offsetWidth;
      let xScaled = e.clientX - rect.left;
      xScaled = Math.max(0, Math.min(xScaled, rect.width));
      const value = xScaled / rect.width;
      updateCrossfader(value);
      const leftCSS = value * railCSSWidth - HANDLE_HALF;
      crossfaderHandle.style.left = `${leftCSS}px`;
    });
    crossfaderHandle.addEventListener('touchstart',(e)=>{
      if (e.touches && e.touches.length > 1) return;
      e.preventDefault(); isDraggingX=true;
    }, {passive:false});
    document.addEventListener('touchmove',(e)=>{
      if (!isDraggingX || !e.touches || !e.touches.length) return;
      if (e.touches.length > 1) return;
      const rect = crossfaderRail.getBoundingClientRect();
      const railCSSWidth = crossfaderRail.offsetWidth;
      let xScaled = e.touches[0].clientX - rect.left;
      xScaled = Math.max(0, Math.min(xScaled, rect.width));
      const value = xScaled / rect.width;
      updateCrossfader(value);
      const leftCSS = value * railCSSWidth - HANDLE_HALF;
      crossfaderHandle.style.left = `${leftCSS}px`;
    }, {passive:false});
    document.addEventListener('touchend', ()=>{ isDraggingX=false; });

    /* -------- Wire ALL sliders -------- */
    masterVolControl.addEventListener('input', (e)=> updateMasterVol(parseFloat(e.target.value)));
    hpVolControl.addEventListener('input', (e)=> { if (cueGain) cueGain.gain.value = parseFloat(e.target.value); });
    hpMixControl.addEventListener('input', (e)=> updateHPMix(parseFloat(e.target.value)));

    masterFilterFreq.addEventListener('input', (e)=> updateFilterFreq(parseFloat(e.target.value)));
    delayWetDryControl.addEventListener('input', (e)=> updateFXWetDry('delay', parseFloat(e.target.value)));
    reverbWetDryControl.addEventListener('input', (e)=> updateFXWetDry('reverb', parseFloat(e.target.value)));
    delayFeedbackControl.addEventListener('input', (e)=> updateDelayFeedback(parseFloat(e.target.value)));
    delayTimeActualControl.addEventListener('input', (e)=> updateDelayTime(parseFloat(e.target.value)));
  </script>

  <!-- Stylus (triangle; silent while dragging; resumes only if it was playing; anchored to plate) -->
  <script>
    (function(){
      var SAFE_GAP_PX = 6;

      function computeTravelPx(record){
        var w = record.clientWidth;
        var radius = w / 2;
        var label = record.querySelector('.record-label');
        var labelR = label ? (label.clientWidth / 2) : 0;
        var span = Math.max(10, Math.floor((radius - labelR) - SAFE_GAP_PX));
        return span;
      }

      function createStylus(record){
        var plate = record.parentElement;
        if (!plate) return;

        var slider = document.createElement('div');
        slider.className = 'stylus-slider';
        slider.style.width = computeTravelPx(record) + 'px';

        var hit = document.createElement('div');
        hit.className = 'stylus-hitbox';
        var handle = document.createElement('div');
        handle.className = 'stylus-handle';
        hit.appendChild(handle);
        slider.appendChild(hit);
        plate.appendChild(slider);

        var dragging = false, value = 0, wasPlaying = false;

        function render(){
          var w = slider.clientWidth;
          var hw = 24;
          var x = (1 - value) * w - hw/2;
          if (x < -hw/2) x = -hw/2;
          if (x >  w - hw/2) x = w - hw/2;
          hit.style.left = x + 'px';
        }

        function getDeckState(){
          var deckRoot = record.closest('[id^="deck"]');
          var deckId   = deckRoot ? deckRoot.id.replace('deck','').toUpperCase() : null;
          if (!deckId || !window.decks) return null;
          return { deckId, st: window.decks[deckId].state };
        }

        function liftStylus(){
          var d = getDeckState(); if (!d) return;
          var st = d.st;
          wasPlaying = !!st.isPlaying;
          if (st.source){ try{ st.source.stop(); st.source.disconnect(); }catch(e){} st.source=null; }
          st.isPlaying = false;
          var deck = window.decks[d.deckId];
          if (deck) deck.light.classList.remove('active');
        }

        function dropStylus(){
          var d = getDeckState(); if (!d) return;
          var deckId = d.deckId, st = d.st;
          if (!st || !st.buffer) return;

          st.playbackPos = value * st.buffer.duration;

          if (value >= 0.999){
            if (typeof window.stopDeck === 'function') window.stopDeck(deckId);
            return;
          }

          if (wasPlaying){
            var src = audioCtx.createBufferSource();
            src.buffer = st.buffer;
            src.connect(st.eq.low);
            src.playbackRate.value = st.rate || 1.0;
            st.rateNode = src.playbackRate;
            st.source = src; st.isPlaying = true; st.lastUpdateTime = audioCtx.currentTime; st._rotLast = 0;
            src.start(0, st.playbackPos);
            src.onended = function(){ if (st.isPlaying && typeof window.stopDeck === 'function'){ window.stopDeck(deckId); } };
            var deck = window.decks[deckId];
            if (deck) deck.light.classList.add('active');
          } else {
            st.isPlaying = false;
          }
        }

        function setFromPlayback(){
          try{
            var d = getDeckState();
            if (!d) return;
            var st = d.st;
            if (st && st.buffer && !dragging){
              value = st.playbackPos / st.buffer.duration;
              if (value > 0.999) value = 0.999;
              render();
            }
          }catch(e){}
        }

        function start(e){
          if (e.touches && e.touches.length > 1) return;
          e.preventDefault();
          dragging = true;
          liftStylus();
        }
        function move(clientX){
          if (!dragging) return;
          var rect = slider.getBoundingClientRect();
          var x = Math.max(0, Math.min(clientX - rect.left, rect.width));
          value = 1 - (x / rect.width);
          render();
        }
        function end(){
          if (!dragging) return;
          dragging = false;
          dropStylus();
        }

        hit.addEventListener('mousedown', function(e){ start(e); });
        document.addEventListener('mousemove', function(e){ move(e.clientX); });
        document.addEventListener('mouseup', end);

        hit.addEventListener('touchstart', function(e){ start(e); }, { passive:false });
        document.addEventListener('touchmove', function(e){
          if(e.touches && e.touches.length > 1) return;
          if(e.touches && e.touches.length){ move(e.touches[0].clientX); }
        }, { passive:false });
        document.addEventListener('touchend', end);

        slider.addEventListener('click', function(e){
          var d = getDeckState(); if (!d) return;
          liftStylus();
          var rect = slider.getBoundingClientRect();
          var x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
          value = 1 - (x / rect.width);
          render();
          dropStylus();
        });

        function resize(){ slider.style.width = computeTravelPx(record) + 'px'; render(); }
        window.addEventListener('resize', resize);

        function sync(){ setFromPlayback(); requestAnimationFrame(sync); }
        requestAnimationFrame(sync);
        render();
      }

      function boot(){ document.querySelectorAll('.record').forEach(createStylus); }
      if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); } else { boot(); }
    })();
  </script>
</body>
</html>
