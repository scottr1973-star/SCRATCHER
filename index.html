<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Scratcher Pro 2026 - Fluid</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Inter:wght@500;700;900&display=swap');

    :root {
      --bg-deep: #050507;
      --border-subtle: rgba(255, 255, 255, 0.15);
      --accent-primary: #0ea5e9;
      --text-main: #f1f5f9;
      --text-muted: #94a3b8;
    }

    html, body { 
        height: 100%; width: 100%; margin: 0; padding: 0;
        overflow: hidden; 
        background-color: var(--bg-deep);
        background-image: radial-gradient(circle at center, #15151a 0%, #000 100%);
        font-family: 'Inter', sans-serif;
        color: var(--text-main);
        -webkit-font-smoothing: antialiased;
        touch-action: none;
    }

    /* FLUID CONTAINER - No fixed pixels */
    .dj-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 1vh 1vw; /* Tiny padding */
      box-sizing: border-box;
    }

    /* --- HEADER --- */
    #fileLoader {
      flex: 0 0 auto; /* Don't shrink */
      height: 50px;
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 16px;
      margin-bottom: 8px;
      background: #0a0a0c;
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
    }
    .app-title { font-weight: 900; font-size: clamp(1rem, 2vw, 1.5rem); letter-spacing: -0.02em; white-space: nowrap; }
    .file-loader-group { display: flex; gap: 8px; align-items: center; }
    
    .mini-btn {
      background: linear-gradient(180deg, #2a2a30, #1a1a20);
      color: var(--text-main); font-size: 0.7rem; font-weight: 700;
      padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1);
      cursor: pointer; text-transform: uppercase; white-space: nowrap;
    }
    .mini-btn.red { background: linear-gradient(180deg, #7f1d1d, #450a0a); border-color: #991b1b; }

    /* --- DECK LAYOUT (GRID) --- */
    .main-mix {
      flex: 1; /* Take all remaining height */
      display: grid;
      /* 3 Columns: Deck A, Mixer (fixed max width), Deck B */
      grid-template-columns: 1fr minmax(280px, 25%) 1fr; 
      gap: 1vw;
      min-height: 0; /* Critical for scrolling prevention */
    }

    .turntable {
      background: linear-gradient(180deg, #25252b 0%, #15151a 100%);
      border: 1px solid var(--border-subtle); border-radius: 16px;
      padding: 1.5vh 1.5vw;
      display: flex; flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    .mixer {
      background: #15151a; border: 1px solid var(--border-subtle); border-radius: 16px;
      padding: 1.5vh 1vw;
      display: flex; flex-direction: column;
      justify-content: space-between; /* Space out faders vertically */
      gap: 1vh;
    }

    /* --- COMPONENT STYLES --- */
    label { 
        font-size: 0.65rem; font-weight: 700; color: #94a3b8; 
        letter-spacing: 0.05em; margin-bottom: 2px; display: block; 
    }
    
    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; cursor: grab; margin: 0; }
    input[type=range]:focus { outline: none; }
    
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%; height: 6px; cursor: pointer;
      background: #050507; border-radius: 3px; border: 1px solid #000;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.9);
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; margin-top: -6px;
      background: radial-gradient(circle at 30% 30%, #e2e8f0 0%, #94a3b8 40%, #475569 100%);
      border: 1px solid #000; box-shadow: 0 4px 8px rgba(0,0,0,0.7);
    }

    /* --- EQ & FX --- */
    .eq-section { display: flex; gap: 8px; flex: 0 0 auto; margin-bottom: 1vh; }
    .eq-knob { flex: 1; text-align: center; }
    
    .fx-panel { 
      background: rgba(0,0,0,0.3); border-radius: 12px; padding: 1vh 1vw;
      display: grid; grid-template-columns: 1fr 1fr; gap: 1vh;
      flex: 0 0 auto;
    }
    .fx-control { text-align: center; }

    /* --- RECORD (FLUID SIZE) --- */
    .record-container {
      flex: 1; /* Grow to fill space */
      display: flex; align-items: center; justify-content: center;
      min-height: 0;
      padding: 1vh 0;
    }
    .record-plate {
      /* Key to fluid sizing: responsive to Viewport Min (vmin) but capped */
      width: 35vmin; height: 35vmin;
      max-width: 320px; max-height: 320px;
      position: relative;
      border-radius: 50%; background: #080808;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6), 0 0 0 6px #18181b, 0 0 0 7px #000;
      flex-shrink: 0;
    }
    .record {
      width: 100%; height: 100%; border-radius: 50%;
      background: repeating-radial-gradient(#111 0, #111 2px, #1a1a1a 3px, #1a1a1a 4px);
      position: relative; touch-action: none; cursor: grab; border: 2px solid #000;
    }
    .record-label {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 35%; height: 35%; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-weight: 900; font-size: 1.5rem; color: #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.2);
      border: 4px solid rgba(0,0,0,0.1);
    }
    #deckA .record-label { background: #f43f5e; }
    #deckB .record-label { background: #3b82f6; }
    .cue-mark {
      position: absolute; top: 5%; left: 50%; transform: translateX(-50%);
      width: 6%; height: 6%; border-radius: 50%; background: #fff; box-shadow: 0 0 10px #fff;
    }

    /* --- DECK CONTROLS --- */
    .deck-controls { 
      flex: 0 0 auto; /* Don't shrink */
      display: flex; flex-direction: column; gap: 1vh; 
    }
    .track-display-window {
      background: #000; border: 1px solid #333; border-radius: 6px; padding: 8px;
      font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--accent-primary);
      text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.8);
    }
    .track-select {
      width: 100%; background: #0f172a; color: #fff; border: 1px solid #334155;
      padding: 8px; border-radius: 8px; font-size: 0.75rem; font-weight: 600;
    }
    .controls-row { display: flex; gap: 8px; }
    
    .btn {
      flex: 1; padding: 12px 0; border-radius: 8px; border: none;
      font-weight: 800; font-size: 0.75rem; cursor: pointer;
      box-shadow: 0 4px 0 rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
      text-transform: uppercase;
    }
    .btn:active { transform: translateY(2px); box-shadow: inset 0 2px 5px rgba(0,0,0,0.6); }
    
    .play-btn { background: linear-gradient(180deg, #334155, #1e293b); color: #fff; }
    .play-btn:active { background: #10b981; }
    .stop-btn { background: linear-gradient(180deg, #334155, #1e293b); color: #f87171; }
    .cue-btn { background: linear-gradient(180deg, #334155, #1e293b); color: #fbbf24; }
    .cue-btn.active { background: #fbbf24; color: #000; transform: translateY(2px); }

    .status-light {
      width: 16px; height: 16px; border-radius: 50%; background: #222;
      align-self: center; box-shadow: inset 0 1px 3px rgba(0,0,0,0.9); border: 1px solid #444; flex-shrink: 0;
    }
    .status-light.active { background: #00ff66; box-shadow: 0 0 15px #00ff66; }

    /* --- MIXER CENTER --- */
    .master-hp-row { display: flex; justify-content: space-between; gap: 10px; flex: 0 0 auto;}
    
    .horizontal-fader-group { 
        display: flex; justify-content: space-between; align-items: center; 
        flex: 1; /* Grow to fill vertical space */
        min-height: 100px;
    }
    
    /* Vertical Faders (Fluid) */
    .fader-control-horizontal { 
        height: 100%; width: 30%;
        display: flex; flex-direction: column; align-items: center; justify-content: center; 
        position: relative;
    }
    /* We use absolute positioning to fake vertical rotation in a flex container */
    .vertical-slider-wrapper {
        width: 100%; height: 100%; position: relative;
        display: flex; justify-content: center; align-items: center;
    }
    #volA, #volB { 
        transform: rotate(-90deg); 
        width: 20vh; /* Responsive length based on screen height */
        max-width: 200px; 
    }
    .fader-control-horizontal input[type=range]::-webkit-slider-thumb {
      border-radius: 2px; height: 28px; width: 40px;
      background: linear-gradient(180deg, #64748b 0%, #334155 50%, #1e293b 100%);
      box-shadow: 0 5px 10px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.3); margin-top: -12px;
    }

    .vu-meter {
      width: 16px; height: 80%; background: #000; border-radius: 4px;
      display: flex; flex-direction: column-reverse; padding: 2px; gap: 2px;
      border: 1px solid #333;
    }
    .vu-segment { height: 10%; width: 100%; background: #1e293b; border-radius: 1px; }
    .vu-segment.on { background: var(--accent-primary); box-shadow: 0 0 8px var(--accent-primary); }
    .vu-segment.yellow.on { background: #facc15; }
    .vu-segment.red.on { background: #ef4444; }

    /* Crossfader */
    .crossfader-container { padding: 1vh 0; flex: 0 0 auto; }
    .crossfader-rail {
      height: 12px; background: #000; border-radius: 6px; position: relative;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.9), 0 1px 0 rgba(255,255,255,0.1); border: 1px solid #111;
    }
    .crossfader-handle {
      width: 50px; height: 36px; 
      background: linear-gradient(180deg, #94a3b8, #475569); border-radius: 4px;
      position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
      cursor: grab; border-top: 1px solid rgba(255,255,255,0.4); border-bottom: 1px solid rgba(0,0,0,0.8);
      box-shadow: 0 6px 12px rgba(0,0,0,0.7);
    }
    .crossfader-handle::after {
      content: ''; position: absolute; top: 8px; left: 18px; right: 18px; bottom: 8px;
      border-top: 2px solid rgba(0,0,0,0.3); border-bottom: 2px solid rgba(0,0,0,0.3);
    }

    /* Stylus */
    .stylus-slider {
      position: absolute; top: 50%; right: 0; height: 6px; background: rgba(255,255,255,0.1);
      transform: translateY(-50%); z-index: 10; pointer-events: none; border-radius: 3px;
    }
    .stylus-hitbox { position: absolute; top: -20px; width: 12px; height: 46px; pointer-events: auto; cursor: ew-resize; }
    .stylus-handle {
      width: 0; height: 0; 
      border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 24px solid var(--accent-primary);
      filter: drop-shadow(0 0 6px var(--accent-primary));
    }

  </style>
</head>
<body>
  
  <div class="dj-container">
      
      <div id="fileLoader">
        <h1 class="app-title">SCRATCHER <span style="font-weight:300; color:var(--accent-primary); font-size:0.8em;">PRO</span></h1>
        <div class="file-loader-group">
          <input type="file" id="musicFiles" multiple webkitdirectory directory style="display:none;">
          <input type="file" id="filePicker" multiple accept="audio/*" style="display:none;">
          <button id="loadFilesBtn" class="mini-btn">üìÅ Folder</button>
          <button id="addFilesBtn"  class="mini-btn">üìÑ Files</button>
          <button id="clearLibBtn"  class="mini-btn red">‚úï Clear</button>
        </div>
        <div id="loadingStatus" class="text-xs text-gray-400 font-bold tracking-wide">EMPTY</div>
      </div>

      <div class="main-mix">
        
        <div class="turntable" id="deckA">
          <div class="track-display-window" id="statusA">NO TRACK LOADED</div>
          
          <div class="eq-section">
            <div class="eq-knob"><label>HI</label><input type="range" id="eqHighA" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label>MID</label><input type="range" id="eqMidA" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label>LO</label><input type="range" id="eqLowA" min="-12" max="12" step="0.1" value="0.0"></div>
          </div>

          <div class="record-container">
            <div class="record-plate">
              <div class="record" id="recordA">
                <div class="record-label">A</div>
                <div class="cue-mark"></div>
              </div>
            </div>
          </div>

          <div class="deck-controls">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <label>PITCH</label>
              <input type="range" id="pitchA" min="0.5" max="1.5" step="0.01" value="1.0" style="width:70%">
            </div>
            
            <select class="track-select" id="trackSelectA"><option value="-1" disabled selected>Select Track A</option></select>

            <div class="controls-row">
              <button class="btn play-btn" id="playA">PLAY</button>
              <button class="btn cue-btn"  id="cueA">CUE</button>
              <button class="btn stop-btn" id="stopA">STOP</button>
              <div class="status-light" id="lightA"></div>
            </div>
            
            <div class="controls-row">
              <button class="mini-btn" id="unloadA" style="flex:1">Unload</button>
              <button class="mini-btn red" id="removeA" style="flex:1">Remove</button>
            </div>
          </div>
        </div>

        <div class="mixer">
          
          <div class="master-hp-row">
            <div style="width:48%">
              <label>MASTER</label>
              <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.9">
            </div>
            <div style="width:48%">
              <label>PHONES</label>
              <input type="range" id="hpVol" min="0" max="1" step="0.01" value="0.8">
            </div>
          </div>

          <div class="horizontal-fader-group">
            <div class="fader-control-horizontal">
              <div class="vertical-slider-wrapper">
                <input type="range" id="volA" min="0" max="1" step="0.01" value="0.7">
              </div>
              <label>CH A</label>
            </div>

            <div class="master-controls-group" style="display:flex; flex-direction:column; align-items:center;">
              <div class="vu-meter" id="masterVUMeter">
                <div class="vu-segment red" data-level="10"></div>
                <div class="vu-segment red" data-level="9"></div>
                <div class="vu-segment yellow" data-level="8"></div>
                <div class="vu-segment yellow" data-level="7"></div>
                <div class="vu-segment" data-level="6"></div>
                <div class="vu-segment" data-level="5"></div>
                <div class="vu-segment" data-level="4"></div>
                <div class="vu-segment" data-level="3"></div>
                <div class="vu-segment" data-level="2"></div>
                <div class="vu-segment" data-level="1"></div>
              </div>
              <label style="margin-top:5px">dB</label>
            </div>

            <div class="fader-control-horizontal">
              <div class="vertical-slider-wrapper">
                <input type="range" id="volB" min="0" max="1" step="0.01" value="0.7">
              </div>
              <label>CH B</label>
            </div>
          </div>

          <div class="fx-panel">
            <div class="fx-control">
              <label>FILTER</label>
              <input type="range" id="masterFilterFreq" min="100" max="18000" step="10" value="18000">
            </div>
            <div class="fx-control">
              <label>DLY MIX</label>
              <input type="range" id="delayWetDry" min="0" max="1" step="0.01" value="0.0">
            </div>
            <div class="fx-control">
              <label>DLY TIME</label>
              <input type="range" id="delayTime" min="0.05" max="0.5" step="0.01" value="0.3">
            </div>
            <div class="fx-control">
              <label>DLY FB</label>
              <input type="range" id="delayFeedback" min="0.1" max="0.9" step="0.01" value="0.3">
            </div>
            <div class="fx-control">
              <label>RVB MIX</label>
              <input type="range" id="reverbWetDry" min="0" max="1" step="0.01" value="0.0">
            </div>
            <div class="fx-control">
              <label>CUE MIX</label>
              <input type="range" id="hpMix" min="0" max="1" step="0.01" value="0.5">
            </div>
          </div>

          <div class="crossfader-container">
            <label style="text-align:center;">CROSSFADER</label>
            <div class="crossfader-rail" id="crossfaderRail">
              <div class="crossfader-handle" id="crossfaderHandle"></div>
            </div>
            <div style="display:flex; justify-content:space-between; padding-top:4px;">
              <span class="text-xs font-bold text-gray-500">A</span>
              <span class="text-xs font-bold text-gray-500">B</span>
            </div>
          </div>
        </div>

        <div class="turntable" id="deckB">
          <div class="track-display-window" id="statusB">NO TRACK LOADED</div>
          
          <div class="eq-section">
            <div class="eq-knob"><label>HI</label><input type="range" id="eqHighB" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label>MID</label><input type="range" id="eqMidB" min="-12" max="12" step="0.1" value="0.0"></div>
            <div class="eq-knob"><label>LO</label><input type="range" id="eqLowB" min="-12" max="12" step="0.1" value="0.0"></div>
          </div>

          <div class="record-container">
            <div class="record-plate">
              <div class="record" id="recordB">
                <div class="record-label">B</div>
                <div class="cue-mark"></div>
              </div>
            </div>
          </div>

          <div class="deck-controls">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <label>PITCH</label>
              <input type="range" id="pitchB" min="0.5" max="1.5" step="0.01" value="1.0" style="width:70%">
            </div>

            <select class="track-select" id="trackSelectB"><option value="-1" disabled selected>Select Track B</option></select>

            <div class="controls-row">
              <button class="btn play-btn" id="playB">PLAY</button>
              <button class="btn cue-btn"  id="cueB">CUE</button>
              <button class="btn stop-btn" id="stopB">STOP</button>
              <div class="status-light" id="lightB"></div>
            </div>

            <div class="controls-row">
              <button class="mini-btn" id="unloadB" style="flex:1">Unload</button>
              <button class="mini-btn red" id="removeB" style="flex:1">Remove</button>
            </div>
          </div>
        </div>

      </div>
    </div>
  

  <script>
    /* --------- LOGIC CORE (Multitouch + Logic from working version) --------- */
    let TRACKS = [];
    let TRACK_KEYS = new Set();
    let audioCtx;
    let animationFrameId;
    let crossfaderGainA, crossfaderGainB, masterFilter, delayNode, feedbackGain, delayWetGain, reverbWetGain, reverbDelay, reverbLowPass, cueGain, masterOutGain;
    let masterVolGain;
    let masterPreListen;
    let analyserNode;

    const DECK_A = { id:'A', trackIndex:-1, buffer:null, source:null, gain:null, rate:1.0, isPlaying:false, playbackPos:0, lastUpdateTime:0, currentRotation:0, _rotLast:0, eq:{low:null,mid:null,high:null,scratch:null}, hasMoved:false, isDragging:false, startAngle:0, baseRotation:0, accumAngle:0, startPlaybackPos:0, manualRotate:false, rateNode:null, touchId: null };
    const DECK_B = { id:'B', trackIndex:-1, buffer:null, source:null, gain:null, rate:1.0, isPlaying:false, playbackPos:0, lastUpdateTime:0, currentRotation:0, _rotLast:0, eq:{low:null,mid:null,high:null,scratch:null}, hasMoved:false, isDragging:false, startAngle:0, baseRotation:0, accumAngle:0, startPlaybackPos:0, manualRotate:false, rateNode:null, touchId: null };

    const $ = id => document.getElementById(id);
    const decks = {
      A:{ state:DECK_A, recordEl:$('recordA'), trackSelectEl:$('trackSelectA'), playBtn:$('playA'), stopBtn:$('stopA'), cueBtn:$('cueA'), light:$('lightA'), status:$('statusA'), pitch:$('pitchA'), vol:$('volA'), eqLow:$('eqLowA'), eqMid:$('eqMidA'), eqHigh:$('eqHighA') },
      B:{ state:DECK_B, recordEl:$('recordB'), trackSelectEl:$('trackSelectB'), playBtn:$('playB'), stopBtn:$('stopB'), cueBtn:$('cueB'), light:$('lightB'), status:$('statusB'), pitch:$('pitchB'), vol:$('volB'), eqLow:$('eqLowB'), eqMid:$('eqMidB'), eqHigh:$('eqHighB') },
    };
    window.decks = decks;

    const crossfaderHandle = $('crossfaderHandle');
    const crossfaderRail   = $('crossfaderRail');
    const delayWetDryControl = $('delayWetDry');
    const reverbWetDryControl = $('reverbWetDry');
    const delayFeedbackControl = $('delayFeedback');
    const delayTimeActualControl = $('delayTime');
    const masterFilterFreq = $('masterFilterFreq');
    const hpVolControl = $('hpVol');
    const musicFilesInput = $('musicFiles');
    const filePicker      = $('filePicker');
    const loadFilesBtn    = $('loadFilesBtn');
    const addFilesBtn     = $('addFilesBtn');
    const clearLibBtn     = $('clearLibBtn');
    const loadingStatus   = $('loadingStatus');
    const masterVolControl = $('masterVol');
    const masterVUMeter = $('masterVUMeter');
    const hpMixControl = $('hpMix');
    const vuSegments = Array.from(masterVUMeter.querySelectorAll('.vu-segment'));

    const BLANK_DISPLAY_TEXT = 'NO TRACK LOADED';
    const RECORD_PADDING_PERCENT = 0.1;
    const SECS_PER_REV = 60/33.333;

    function initAudio(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      cueGain = audioCtx.createGain();
      cueGain.gain.value = parseFloat(hpVolControl.value);
      cueGain.connect(audioCtx.destination);

      masterPreListen = audioCtx.createGain();
      updateHPMix(parseFloat(hpMixControl.value));
      masterPreListen.connect(cueGain);

      masterOutGain = audioCtx.createGain();
      masterOutGain.gain.value = 1.0;

      masterVolGain = audioCtx.createGain();
      masterVolGain.gain.value = parseFloat(masterVolControl.value);

      masterFilter = audioCtx.createBiquadFilter();
      masterFilter.type = 'lowpass';
      masterFilter.frequency.value = parseFloat(masterFilterFreq.value);
      masterFilter.Q.value = .5;

      delayNode = audioCtx.createDelay(1.0);
      delayNode.delayTime.value = parseFloat(delayTimeActualControl.value);

      feedbackGain = audioCtx.createGain();
      feedbackGain.gain.value = parseFloat(delayFeedbackControl.value);

      delayWetGain = audioCtx.createGain();
      delayWetGain.gain.value = parseFloat(delayWetDryControl.value);

      reverbLowPass = audioCtx.createBiquadFilter();
      reverbLowPass.type = 'lowpass';
      reverbLowPass.frequency.value = 4000;
      reverbLowPass.Q.value = .5;

      reverbDelay = audioCtx.createDelay(.3);
      reverbDelay.delayTime.value = .05;

      reverbWetGain = audioCtx.createGain();
      reverbWetGain.gain.value = parseFloat(reverbWetDryControl.value);

      delayNode.connect(feedbackGain);
      feedbackGain.connect(delayNode);
      delayNode.connect(delayWetGain);

      masterFilter.connect(reverbDelay);
      reverbDelay.connect(reverbLowPass);
      reverbLowPass.connect(reverbWetGain);

      masterOutGain.connect(delayNode);
      masterOutGain.connect(masterFilter);

      masterFilter.connect(masterVolGain);
      delayWetGain.connect(masterVolGain);
      reverbWetGain.connect(masterVolGain);

      masterVolGain.connect(audioCtx.destination);
      masterVolGain.connect(masterPreListen);

      analyserNode = audioCtx.createAnalyser();
      analyserNode.fftSize = 256;
      masterVolGain.connect(analyserNode);

      crossfaderGainA = audioCtx.createGain();
      crossfaderGainB = audioCtx.createGain();

      initDeckAudio(DECK_A, crossfaderGainA);
      initDeckAudio(DECK_B, crossfaderGainB);

      crossfaderGainA.connect(masterOutGain);
      crossfaderGainB.connect(masterOutGain);

      updateCrossfader(.5);
      requestAnimationFrame(update);
    }

    function initDeckAudio(deckState, crossfaderGain){
      deckState.gain = audioCtx.createGain();
      deckState.gain.gain.value = parseFloat($('vol'+deckState.id).value);
      deckState.gain.connect(crossfaderGain);

      deckState.cueNode = audioCtx.createGain();
      deckState.cueNode.gain.value = 0.0;
      deckState.cueNode.connect(masterPreListen);

      const eqLow  = audioCtx.createBiquadFilter();  eqLow.type='lowshelf';  eqLow.frequency.value=320;  eqLow.gain.value=parseFloat($('eqLow'+deckState.id).value);
      const eqMid  = audioCtx.createBiquadFilter();  eqMid.type='peaking';   eqMid.frequency.value=1000; eqMid.Q.value=1.0; eqMid.gain.value=parseFloat($('eqMid'+deckState.id).value);
      const eqHigh = audioCtx.createBiquadFilter();  eqHigh.type='highshelf';eqHigh.frequency.value=3200; eqHigh.gain.value=parseFloat($('eqHigh'+deckState.id).value);

      const scratchFilter = audioCtx.createBiquadFilter();
      scratchFilter.type='highpass'; scratchFilter.frequency.value=20; scratchFilter.Q.value=1.0;

      deckState.eq = { low:eqLow, mid:eqMid, high:eqHigh, scratch:scratchFilter };

      eqLow.connect(eqMid); eqMid.connect(eqHigh); eqHigh.connect(scratchFilter);
      scratchFilter.connect(deckState.gain);
      scratchFilter.connect(deckState.cueNode);
    }

    function populateTrackSelects(preserveByName = true){
      const selNameA = (decks.A.state.trackIndex >= 0 && TRACKS[decks.A.state.trackIndex]) ? TRACKS[decks.A.state.trackIndex].fileName : null;
      const selNameB = (decks.B.state.trackIndex >= 0 && TRACKS[decks.B.state.trackIndex]) ? TRACKS[decks.B.state.trackIndex].fileName : null;

      const A = decks.A.trackSelectEl, B = decks.B.trackSelectEl;
      [A,B].forEach(sel => {
        sel.innerHTML = '<option value="-1" disabled selected>SELECT TRACK</option>';
        TRACKS.forEach((t, i) => {
          const opt = document.createElement('option');
          opt.value = i; opt.textContent = t.fileName; sel.appendChild(opt);
        });
      });

      if (preserveByName){
        if (selNameA){
          const idxA = TRACKS.findIndex(t => t.fileName === selNameA);
          if (idxA >= 0){ A.value = String(idxA); loadDeck('A', idxA); }
        }
        if (selNameB){
          const idxB = TRACKS.findIndex(t => t.fileName === selNameB);
          if (idxB >= 0){ B.value = String(idxB); loadDeck('B', idxB); }
        }
      }
    }

    function loadDeck(deckId, idx){
      const deck = decks[deckId], st = deck.state;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      if (idx === -1 || idx >= TRACKS.length){ st.trackIndex=-1; st.buffer=null; deck.status.textContent=BLANK_DISPLAY_TEXT; deck.light.classList.remove('active'); return; }
      const track = TRACKS[idx];
      st.trackIndex=idx; st.buffer=track.buffer; st.playbackPos=0; st.currentRotation=0; st.baseRotation=0; st.accumAngle=0;
      deck.status.textContent = track.fileName.substring(0, 30);
      deck.light.classList.remove('active');
      updatePitch(deckId, parseFloat(deck.pitch.value));
    }

    function unloadDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      stopDeck(deckId);
      st.buffer = null; st.trackIndex = -1; st.playbackPos = 0;
      deck.trackSelectEl.value = "-1";
      deck.status.textContent = BLANK_DISPLAY_TEXT;
    }

    function removeCurrentTrackFromLibrary(deckId){
      const deck = decks[deckId], st = deck.state;
      if (st.trackIndex < 0 || st.trackIndex >= TRACKS.length) return;
      removeTrackByIndex(st.trackIndex);
    }

    function removeTrackByIndex(idx){
      ['A','B'].forEach(id => {
        const d = decks[id], st = d.state;
        if (st.trackIndex === idx){
          stopDeck(id);
          st.buffer = null;
          st.trackIndex = -1;
          d.trackSelectEl.value = "-1";
          d.status.textContent = BLANK_DISPLAY_TEXT;
        } else if (st.trackIndex > idx){
          st.trackIndex -= 1;
        }
      });

      const removed = TRACKS.splice(idx, 1)[0];
      if (removed && removed._key){ TRACK_KEYS.delete(removed._key); }
      populateTrackSelects(false);
      updateLibraryStatus();
    }

    function playDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      if (!st.buffer) return;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }

      const src = audioCtx.createBufferSource();
      src.buffer = st.buffer; src.connect(st.eq.low);
      src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;

      st.source = src; st.isPlaying = true; st.lastUpdateTime = audioCtx.currentTime; st._rotLast = 0;
      src.start(0, st.playbackPos);
      deck.light.classList.add('active');

      src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
    }
    window.playDeck = playDeck;

    function stopDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      st.isPlaying=false;
      if (deck && deck.light) deck.light.classList.remove('active');
    }
    window.stopDeck = stopDeck;

    function cueDeck(deckId){
      const deck = decks[deckId], st = deck.state;
      if (!st.buffer) return;
      deck.cueBtn.classList.toggle('active');
      st.playbackPos = 0;
      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      const src = audioCtx.createBufferSource();
      src.buffer=st.buffer; src.connect(st.eq.low);
      src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;
      st.source=src; st.isPlaying=true; st.lastUpdateTime=audioCtx.currentTime; st._rotLast=0;
      src.start(0, st.playbackPos);
      deck.light.classList.add('active');
      src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
    }

    function updateDeckTime(st){
      if (!st.isPlaying || !st.buffer) return;
      const dt = audioCtx.currentTime - st.lastUpdateTime;
      st.lastUpdateTime = audioCtx.currentTime;
      const rate = st.rateNode ? st.rateNode.value : 1.0;
      st.playbackPos = (st.playbackPos + dt * rate);
      if (st.playbackPos >= st.buffer.duration){
        st.playbackPos = st.buffer.duration;
        st.isPlaying = false;
      }
      if (st.playbackPos < 0) st.playbackPos = 0;
    }

    function updatePitch(deckId, v){ const st = decks[deckId].state; st.rate = v; if (st.source && st.rateNode) st.rateNode.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateVolume(deckId, v){ const st = decks[deckId].state; st.gain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateEQ(deckId, type, v){ const st = decks[deckId].state; st.eq[type].gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateMasterVol(v){ masterVolGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateHPMix(v){ masterPreListen.gain.value = v; }

    function updateCrossfader(value){
      const aGain = Math.cos(value * 0.5 * Math.PI);
      const bGain = Math.cos((1.0 - value) * 0.5 * Math.PI);
      crossfaderGainA.gain.value = aGain;
      crossfaderGainB.gain.value = bGain;
    }
    function updateFilterFreq(v){ masterFilter.frequency.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateDelayFeedback(v){ feedbackGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateDelayTime(v){ delayNode.delayTime.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }
    function updateFXWetDry(fx, v){ if (fx==='delay') delayWetGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); else if (fx==='reverb') reverbWetGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + .05); }

    function updateVUMeter(){
      if (!analyserNode) return;
      const N = analyserNode.frequencyBinCount, data = new Uint8Array(N);
      analyserNode.getByteFrequencyData(data);
      let sum = 0; for (let i=0;i<N;i++){ sum += data[i]*i; }
      const norm = Math.min(10, Math.max(0, Math.ceil(sum / (N * 100))));
      vuSegments.forEach((seg, idx) => seg.classList.toggle('on', (10-idx) <= norm));
    }

    function update(){
      updateDeckTime(DECK_A); updateDeckTime(DECK_B);
      updateRecordRotation(DECK_A); updateRecordRotation(DECK_B);
      updateVUMeter();
      animationFrameId = requestAnimationFrame(update);
    }

    function updateRecordRotation(st){
      if (!st.buffer) return;
      if (st.isDragging || st.manualRotate) return;
      const now = performance.now() * 0.001;
      if (!st._rotLast) st._rotLast = now;
      const dt = now - st._rotLast;
      st._rotLast = now;

      let rate = 0;
      if (st.isPlaying) rate = st.rateNode ? st.rateNode.value : 1.0;

      if (rate !== 0){
        const rotationSpeedDegPerSec = rate * 360;
        st.currentRotation = (st.currentRotation + rotationSpeedDegPerSec * dt);
        const deck = decks[st.id];
        if (deck && deck.recordEl){
          deck.recordEl.style.transform = `rotate(${st.currentRotation}deg)`;
        }
      }
    }

    function pointerAngleDeg(el, clientX, clientY){
      const rect = el.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top  + rect.height/2;
      const dx = clientX - cx;
      const dy = clientY - cy;
      return Math.atan2(dy, dx) * 180/Math.PI;
    }
    function shortestDelta(a, b){
      let d = b - a;
      while (d > 180) d -= 360;
      while (d < -180) d += 360;
      return d;
    }

    function jumpToPosition(deckId, e){
      const deck = decks[deckId], st = deck.state, recordEl = deck.recordEl;
      if (!st.buffer) return;

      const rect = recordEl.getBoundingClientRect();
      const radius  = rect.width/2;
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;

      const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
      const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0] ? e.touches[0].clientY : e.clientY : e.clientY);

      const dx = clientX - cx, dy = clientY - cy;
      const distance = Math.sqrt(dx*dx + dy*dy);
      let normalized = distance / radius;

      const P = RECORD_PADDING_PERCENT;
      let t = (normalized - P) / (1 - 2*P);
      t = Math.max(0, Math.min(1, t));

      const newPos = t * st.buffer.duration;
      st.playbackPos = newPos;

      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }

      const src = audioCtx.createBufferSource();
      src.buffer = st.buffer; src.connect(st.eq.low);
      src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;

      st.source = src; st.isPlaying = true; st.lastUpdateTime = audioCtx.currentTime; st._rotLast = 0;
      src.start(0, st.playbackPos);
      deck.light.classList.add('active');
      src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
    }

    let activeDeck = null;

    /* -------- Crossfader Logic -------- */
    let isDraggingX = false;
    let crossfaderTouchId = null;
    const HANDLE_HALF = 25; 

    function setCrossfaderUI(value){
      const railWidth = crossfaderRail.offsetWidth;
      const leftCSS = value * railWidth - HANDLE_HALF;
      crossfaderHandle.style.left = `${leftCSS}px`;
    }
    window.addEventListener('load', ()=> setCrossfaderUI(.5));

    crossfaderHandle.addEventListener('mousedown', (e)=>{ e.preventDefault(); isDraggingX=true; });
    document.addEventListener('mouseup',  ()=>{ isDraggingX=false; });
    document.addEventListener('mousemove',(e)=>{
      if (!isDraggingX) return;
      const rect = crossfaderRail.getBoundingClientRect();
      const railWidth = crossfaderRail.offsetWidth;
      let xScaled = e.clientX - rect.left;
      xScaled = Math.max(0, Math.min(xScaled, rect.width));
      const value = xScaled / rect.width;
      updateCrossfader(value);
      const leftCSS = value * railWidth - HANDLE_HALF;
      crossfaderHandle.style.left = `${leftCSS}px`;
    });

    crossfaderHandle.addEventListener('touchstart',(e)=>{
      e.preventDefault(); isDraggingX=true;
      crossfaderTouchId = e.changedTouches[0].identifier;
    }, {passive:false});

    document.addEventListener('touchmove',(e)=>{
      if (!isDraggingX) return;
      let touch = null;
      for(let i=0; i<e.changedTouches.length; i++){
        if(e.changedTouches[i].identifier === crossfaderTouchId){ touch = e.changedTouches[i]; break; }
      }
      if(!touch) return;

      const rect = crossfaderRail.getBoundingClientRect();
      const railWidth = crossfaderRail.offsetWidth;
      let xScaled = touch.clientX - rect.left;
      xScaled = Math.max(0, Math.min(xScaled, rect.width));
      const value = xScaled / rect.width;
      updateCrossfader(value);
      const leftCSS = value * railWidth - HANDLE_HALF;
      crossfaderHandle.style.left = `${leftCSS}px`;
    }, {passive:false});

    document.addEventListener('touchend', (e)=>{
       if(!isDraggingX) return;
       for(let i=0; i<e.changedTouches.length; i++){
         if(e.changedTouches[i].identifier === crossfaderTouchId){
           isDraggingX=false; crossfaderTouchId=null;
         }
       }
    });

    /* -------- Record Touch Logic -------- */
    function handleStart(e, deckId){
      e.preventDefault();
      initAudio();
      audioCtx.resume && audioCtx.resume();

      const deck = decks[deckId], st = deck.state, el = deck.recordEl;
      if (!st.buffer) return;

      let cx, cy;
      if (e.type === 'touchstart') {
          const t = e.changedTouches[0];
          st.touchId = t.identifier; 
          cx = t.clientX; cy = t.clientY;
      } else {
          cx = e.clientX; cy = e.clientY;
      }

      st.isDragging = true; st.manualRotate = true; 
      activeDeck = deck; 
      st.hasMoved = false;

      if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
      st.isPlaying = false;
      deck.light.classList.remove('active');

      st.startAngle = pointerAngleDeg(el, cx, cy);
      st.baseRotation = st.currentRotation;
      st.accumAngle = 0;
      st.startPlaybackPos = st.playbackPos;
    }

    function handleMove(e){
      if (!activeDeck || !activeDeck.state.isDragging) return;
      const deck = activeDeck, st = deck.state, el = deck.recordEl;
      let cx = null, cy = null;

      if (e.type === 'touchmove') {
          for(let i=0; i<e.changedTouches.length; i++){
              if(e.changedTouches[i].identifier === st.touchId){
                  cx = e.changedTouches[i].clientX;
                  cy = e.changedTouches[i].clientY;
                  break;
              }
          }
          if(cx === null) return; 
      } else {
          cx = e.clientX; cy = e.clientY;
      }
      e.preventDefault(); 
      st.hasMoved = true;

      const nowAngle = pointerAngleDeg(el, cx, cy);
      st.accumAngle += shortestDelta(st.startAngle, nowAngle);
      st.startAngle = nowAngle;

      st.currentRotation = st.baseRotation + st.accumAngle;
      el.style.transform = `rotate(${st.currentRotation}deg)`;

      const dSecs = (st.accumAngle / 360) * SECS_PER_REV;
      st.playbackPos = Math.max(0, Math.min((st.startPlaybackPos + dSecs), st.buffer.duration));
    }

    function handleEnd(e){
      if (!activeDeck || !activeDeck.state.isDragging) return;
      const deckId = activeDeck.state.id;
      const st = activeDeck.state;

      if (e.type === 'touchend' || e.type === 'touchcancel') {
          let found = false;
          for(let i=0; i<e.changedTouches.length; i++){
              if(e.changedTouches[i].identifier === st.touchId){
                  found = true; break;
              }
          }
          if(!found) return; 
      }

      st.isDragging=false; st.manualRotate=false; st.touchId=null;

      if (st.buffer){
        if (st.source){ st.source.stop(); st.source.disconnect(); st.source=null; }
        const src = audioCtx.createBufferSource();
        src.buffer=st.buffer; src.connect(st.eq.low);
        src.playbackRate.value = st.rate || 1.0; st.rateNode = src.playbackRate;

        st.source=src; st.isPlaying=true; st.lastUpdateTime=audioCtx.currentTime; st._rotLast=0;
        src.start(0, st.playbackPos);
        if (activeDeck.light) activeDeck.light.classList.add('active');

        src.onended = () => { if (st.isPlaying) stopDeck(deckId); };
      }
      activeDeck = null;
    }

    const bindDeck = (deckId)=>{
      const d = decks[deckId];
      d.trackSelectEl.addEventListener('change', (e) => loadDeck(deckId, parseInt(e.target.value)));
      d.playBtn.addEventListener('click', () => { initAudio(); audioCtx.resume && audioCtx.resume(); playDeck(deckId); });
      d.stopBtn.addEventListener('click', () => stopDeck(deckId));
      d.cueBtn.addEventListener('click', () => { initAudio(); audioCtx.resume && audioCtx.resume(); cueDeck(deckId); });
      d.pitch.addEventListener('input', (e) => updatePitch(deckId, parseFloat(e.target.value)));
      d.vol.addEventListener('input',   (e) => updateVolume(deckId, parseFloat(e.target.value)));
      d.eqLow.addEventListener('input', (e) => updateEQ(deckId,'low', parseFloat(e.target.value)));
      d.eqMid.addEventListener('input', (e) => updateEQ(deckId,'mid', parseFloat(e.target.value)));
      d.eqHigh.addEventListener('input',(e) => updateEQ(deckId,'high',parseFloat(e.target.value)));

      $('unload'+deckId).addEventListener('click', () => unloadDeck(deckId));
      $('remove'+deckId).addEventListener('click', () => removeCurrentTrackFromLibrary(deckId));

      const el = d.recordEl;
      el.addEventListener('mousedown', (e)=>handleStart(e, deckId));
      el.addEventListener('touchstart',(e)=>handleStart(e, deckId), {passive:false});
      el.addEventListener('click', (e)=>{ if (!decks[deckId].state.hasMoved) jumpToPosition(deckId, e); });
    };
    bindDeck('A'); bindDeck('B');

    document.addEventListener('mousemove', handleMove);
    document.addEventListener('touchmove', handleMove, {passive:false});
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchend', handleEnd);

    document.body.addEventListener('click', ()=>{ initAudio(); audioCtx.resume && audioCtx.resume(); }, {once:true});
    document.body.addEventListener('touchstart', ()=>{ initAudio(); audioCtx.resume && audioCtx.resume(); }, {once:true});

    /* --------- SCALE ENGINE --------- */
    (function(){
      // Removed fixed pixel sizing logic. 
      // This version relies purely on CSS Viewport units and Flexbox for fluidity.
      // No JS resizing needed anymore.
    })();

    /* Wire all remaining controls */
    masterVolControl.addEventListener('input', (e)=> updateMasterVol(parseFloat(e.target.value)));
    hpVolControl.addEventListener('input', (e)=> { if (cueGain) cueGain.gain.value = parseFloat(e.target.value); });
    hpMixControl.addEventListener('input', (e)=> updateHPMix(parseFloat(e.target.value)));
    masterFilterFreq.addEventListener('input', (e)=> updateFilterFreq(parseFloat(e.target.value)));
    delayWetDryControl.addEventListener('input', (e)=> updateFXWetDry('delay', parseFloat(e.target.value)));
    reverbWetDryControl.addEventListener('input', (e)=> updateFXWetDry('reverb', parseFloat(e.target.value)));
    delayFeedbackControl.addEventListener('input', (e)=> updateDelayFeedback(parseFloat(e.target.value)));
    delayTimeActualControl.addEventListener('input', (e)=> updateDelayTime(parseFloat(e.target.value)));

    /* ---------------- File Logic (Unchanged) ---------------- */
    function isMobileDevice(){
      const ua = navigator.userAgent || '';
      const uad = (navigator.userAgentData && navigator.userAgentData.mobile) ? true : false;
      return /Android|iPhone|iPad|iPod/i.test(ua) || uad;
    }

    loadFilesBtn.addEventListener('click', async () => {
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      const mobile = isMobileDevice();
      if (!mobile && 'showDirectoryPicker' in window) {
        try { await pickDirectoryWithFSAccess(); return; }
        catch (err) { if (err && (err.name === 'AbortError' || err.code === 20)) { loadingStatus.textContent = 'Selection cancelled.'; return; } }
      }
      if (!mobile && ('webkitdirectory' in musicFilesInput)) {
        musicFilesInput.value = ''; musicFilesInput.click(); return;
      }
      filePicker.value = ''; filePicker.click();
    });

    addFilesBtn.addEventListener('click', async ()=>{
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      if ('showOpenFilePicker' in window) {
        try {
          const handles = await window.showOpenFilePicker({
            multiple: true,
            types: [{ description: 'Audio', accept: { 'audio/*': ['.wav','.mp3','.flac','.ogg','.m4a','.aac'] } }]
          });
          const files = await Promise.all(handles.map(h => h.getFile()));
          await loadFilesFromArray(files.filter(isAudioFile));
          return;
        } catch (err) { if (err && (err.name === 'AbortError' || err.code === 20)) { return; } }
      }
      filePicker.value = ''; filePicker.click();
    });

    clearLibBtn.addEventListener('click', ()=>{
      stopDeck('A'); stopDeck('B'); TRACKS = []; TRACK_KEYS.clear();
      populateTrackSelects(); updateLibraryStatus('Library cleared.');
    });

    musicFilesInput.addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files.length) return;
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      await loadFilesFromFileList(e.target.files);
    });
    filePicker.addEventListener('change', async (e) => {
      if (!e.target.files || !e.target.files.length) return;
      try { initAudio(); if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      await loadFilesFromFileList(e.target.files);
    });

    async function pickDirectoryWithFSAccess() {
      const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
      const files = [];
      await collectFilesRecursive(dirHandle, files);
      await loadFilesFromArray(files);
    }
    async function collectFilesRecursive(dirHandle, outArr) {
      for await (const [name, handle] of dirHandle.entries()) {
        if (handle.kind === 'file') {
          const file = await handle.getFile();
          if (isAudioFile(file)) outArr.push(file);
        } else if (handle.kind === 'directory') {
          await collectFilesRecursive(handle, outArr);
        }
      }
    }
    async function loadFilesFromFileList(fileList) {
      const files = Array.from(fileList).filter(isAudioFile);
      await loadFilesFromArray(files);
    }
    async function decodeWithBestSafariCompat(buf){
      try { await audioCtx.resume(); } catch(e){}
      return await new Promise((resolve, reject) => {
        try { audioCtx.decodeAudioData(buf.slice(0), resolve, reject); }
        catch(err){ reject(err); }
      });
    }
    function makeTrackKey(file){ return `${file.name}|${file.size}|${file.type}`.toLowerCase(); }
    function updateLibraryStatus(msg){ loadingStatus.textContent = msg || `Library: ${TRACKS.length} tracks.`; }
    
    async function loadFilesFromArray(files) {
      if (!files.length) { updateLibraryStatus('No audio files found.'); return; }
      if (!audioCtx) initAudio();
      if (TRACKS.length && TRACK_KEYS.size === 0) TRACKS.forEach(t => TRACK_KEYS.add(t._key));

      let added = 0, failed = 0;
      updateLibraryStatus('Loading...');

      for (const file of files) {
        const key = makeTrackKey(file);
        if (TRACK_KEYS.has(key)) continue;
        try {
          const buf = await file.arrayBuffer();
          const decoded = await decodeWithBestSafariCompat(buf);
          TRACKS.push({ fileName: file.name, buffer: decoded, _key: key });
          TRACK_KEYS.add(key);
          added++;
          updateLibraryStatus(`Loaded ${added} tracks...`);
        } catch (err) { failed++; }
      }
      
      if (added > 0) {
        const hadNone = (decks.A.state.trackIndex < 0 && decks.B.state.trackIndex < 0);
        populateTrackSelects(true);
        if (hadNone && TRACKS.length > 0) {
          decks.A.trackSelectEl.value = "0"; loadDeck('A', 0);
          if (TRACKS.length > 1) { decks.B.trackSelectEl.value = "1"; loadDeck('B', 1); }
        }
      }
      updateLibraryStatus(`${added} added, ${failed} failed. Total: ${TRACKS.length}`);
    }

    function isAudioFile(file) {
      return /\.(wav|mp3|m4a|aac|flac|ogg)$/i.test(file.name) || file.type.startsWith('audio/');
    }
  </script>

  <script>
    (function(){
      var SAFE_GAP_PX = 16;
      function computeTravelPx(record){
        var w = record.clientWidth;
        var radius = w / 2;
        var label = record.querySelector('.record-label');
        var labelR = label ? (label.clientWidth / 2) : 0;
        return Math.max(10, Math.floor((radius - labelR) - SAFE_GAP_PX));
      }

      function createStylus(record){
        var plate = record.parentElement;
        if (!plate) return;
        var slider = document.createElement('div');
        slider.className = 'stylus-slider';
        // Width will be set by resize() immediately
        var hit = document.createElement('div');
        hit.className = 'stylus-hitbox';
        var handle = document.createElement('div');
        handle.className = 'stylus-handle';
        hit.appendChild(handle);
        slider.appendChild(hit);
        plate.appendChild(slider);

        var dragging = false, value = 0;
        var stylusTouchId = null;

        function render(){
          var w = slider.clientWidth;
          var hw = 6;
          var x = (1 - value) * w - hw; 
          hit.style.left = Math.max(-hw, Math.min(w - hw, x)) + 'px';
        }

        function getDeckState(){
          var deckRoot = record.closest('[id^="deck"]');
          var deckId   = deckRoot ? deckRoot.id.replace('deck','').toUpperCase() : null;
          if (!deckId || !window.decks) return null;
          return { deckId, st: window.decks[deckId].state };
        }

        function setFromPlayback(){
          try{
            var d = getDeckState(); if (!d) return;
            var st = d.st;
            if (st && st.buffer && !dragging){
              value = st.playbackPos / st.buffer.duration;
              if (value > 0.999) value = 0.999;
              render();
            }
          }catch(e){}
        }

        function start(e){
          e.preventDefault(); dragging = true;
          if(e.type==='touchstart') stylusTouchId = e.changedTouches[0].identifier;
        }
        function move(e){
          if (!dragging) return;
          let cx;
          if(e.type === 'touchmove'){
             let t=null;
             for(let i=0; i<e.changedTouches.length; i++){
               if(e.changedTouches[i].identifier === stylusTouchId){ t=e.changedTouches[i]; break; }
             }
             if(!t) return;
             cx = t.clientX;
          } else { cx = e.clientX; }

          var rect = slider.getBoundingClientRect();
          var x = Math.max(0, Math.min(cx - rect.left, rect.width));
          value = 1 - (x / rect.width);
          render();
          
          var d = getDeckState();
          if (d && d.st && d.st.buffer) {
             d.st.playbackPos = value * d.st.buffer.duration;
          }
        }
        function end(e){
          if (!dragging) return;
          if(e.type==='touchend'){
             let found=false;
             for(let i=0; i<e.changedTouches.length; i++){
               if(e.changedTouches[i].identifier === stylusTouchId){ found=true; break; }
             }
             if(!found) return;
             stylusTouchId = null;
          }
          dragging = false;
        }

        hit.addEventListener('mousedown', start);
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', end);
        hit.addEventListener('touchstart', start, { passive:false });
        document.addEventListener('touchmove', move, { passive:false });
        document.addEventListener('touchend', end);

        function resize(){ slider.style.width = computeTravelPx(record) + 'px'; render(); }
        window.addEventListener('resize', resize);
        function sync(){ setFromPlayback(); requestAnimationFrame(sync); }
        requestAnimationFrame(sync);
        // Force initial render
        setTimeout(resize, 100);
      }

      function boot(){ document.querySelectorAll('.record').forEach(createStylus); }
      if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); } else { boot(); }
    })();
  </script>
</div>
</body>
</html>
