<!DOCTYPE html>
<!--
scratcher22-mobilefix-full.html
- Full build
- Mobile scrolling fixed (both axes), no layout/DOM changes
- Stylus triangle nudged down a few pixels (slightly below true 3 o'clock)
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scratcher - Pro Turntable Controller</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;600;900&display=swap');

        :root {
            --bg-dark: #0F172A; /* Slate 900 */
            --deck-bg: #1E293B; /* Slate 800 */
            --mixer-color: #334155; /* Slate 700 */
            --fader-rail: #475569; /* Slate 600 */
            --accent: #38BDF8; /* Sky 400 */
            --accent-glow: 0 0 8px rgba(56, 189, 248, 0.6);
            --record-surface: #020617; /* Blue-Black */
            --control-label: #94A3B8;

            --shadow-dark: #000000;
            --box-shadow-raised: 10px 10px 20px var(--shadow-dark), -5px -5px 10px #243445; 
            --box-shadow-inset: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px #243445;
        }

        /* --- BASE & LAYOUT (allow scroll on mobile) --- */
        html, body { height: 100%; }
        body {
            height: auto;
            width: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* keep top-anchored */
            align-items: center;
            background-color: var(--bg-dark);
            color: #E2E8F0;
            font-family: 'Inter', sans-serif;
            /* mobile scroll fixes */
            overflow: auto;                  /* was hidden */
            -webkit-overflow-scrolling: touch;
            touch-action: auto;              /* was manipulation */
            padding-top: 0; 
        }

        .dj-container {
            /* keep your 2-decks + mixer layout intact; force horizontal scroll on small screens */
            min-width: 1200px;               /* preserve full layout width */
            width: 95vw; 
            max-width: 1200px; 

            height: auto;                    /* was 100vh */
            min-height: 100svh;              /* mobile-safe viewport height */

            display: flex;
            flex-direction: column;
            padding: 8px;
            background: linear-gradient(145deg, #101824, #0d131f);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9), 0 0 1px #1E293B;
            border: 1px solid #1e293b;

            /* allow scroll (previous build hid overflow) */
            overflow: auto;                  
            -webkit-overflow-scrolling: touch;
        }

        .main-mix {
            display: flex;
            flex-grow: 1;
            min-height: 0; 
        }
        
        .app-title { font-family: 'Orbitron', sans-serif; color: white; font-size: 1.5rem; font-weight: 700; }
        .fader-label, .status-info { color: var(--control-label); font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }

        /* --- FILE LOADER STYLING --- */
        #fileLoader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            padding: 4px 16px;
            margin-bottom: 0px; 
            background: var(--mixer-color); 
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5); 
            border: 1px solid #475569;
        }
        .file-loader-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #loadingStatus {
            order: 3; 
            width: 100%;
            margin-top: 5px;
            text-align: right;
        }

        /* --- TRACK DISPLAY --- */
        .track-display-window {
            width: 100%;
            height: 30px;
            margin-bottom: 5px; 
            padding: 4px 6px; 
            background-color: #020617; 
            border: 3px solid var(--accent); 
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent); 
            font-family: 'Orbitron', monospace;
            font-size: 13px;
            box-shadow: var(--accent-glow), inset 0 0 15px rgba(0, 0, 0, 0.8); 
        }
        
        /* --- SELECT TRACK DROPDOWN --- */
        .track-select {
            width: 100%;
            background-color: #475569; 
            color: #111827; /* Dark text for contrast */
            border: none;
            border-radius: 8px;
            padding: 8px 30px 8px 10px;
            font-size: 12px;
            font-weight: 900; 
            text-align: left;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23111827%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.6-6.4H19a17.6%2017.6%200%200%200-13.6%206.4%2017.6%2017.6%200%200%200%200%2024.3l127.3%20127.9c5.6%205.6%2013.3%208.2%2021.3%208.2s15.7-2.6%2021.3-8.2L287%2093.7a17.9%2017.9%200%200%200%200-24.3z%22%2F%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 10px auto;
        }
        .track-select option {
            color: white; 
            background-color: #1E293B;
        }

        /* --- DECKS & MIXER --- */
        .turntable {
            padding: 15px; 
            background-color: var(--deck-bg);
            border-radius: 12px;
            box-shadow: var(--box-shadow-raised), inset 0 0 15px rgba(0, 0, 0, 0.3);
            margin: 0 8px;
            flex-grow: 1; 
            display: flex; 
            flex-direction: column; 
        }
        .mixer {
            padding: 15px 10px;
            background-color: var(--mixer-color);
            margin: 0 8px;
            border-radius: 12px;
            box-shadow: var(--box-shadow-raised);
            display: flex; 
            flex-direction: column; 
            gap: 5px; 
        }
        .deck-controls {
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            justify-content: space-around; 
        }
        
        /* --- TURNTABLE PLATE STYLES --- */
        .record-plate {
            width: 230px; 
            height: 230px; 
            max-width: 95%; 
            max-height: 95%;
            position: relative;
            align-self: center; 
            margin-top: 5px; 
            margin-bottom: 10px; 
        }
        .record {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: var(--record-surface); 
            border: 4px solid #475569; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.9) inset, 0 8px 15px rgba(0, 0, 0, 0.6); 
            cursor: grab; 
        }
        .record-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: #EF4444; 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 900;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5) inset;
        }
        .cue-mark {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            width: 8%;
            height: 8%;
            border-radius: 50%;
            background-color: #FBBF24; 
        }

        /* --- FADERS & KNOBS --- */
        input[type="range"] {
            box-shadow: var(--box-shadow-inset);
            height: 15px; 
            margin: 0;
            padding: 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.8), 
                        0 0 1px #fff, 
                        inset 1px 1px 3px rgba(255, 255, 255, 0.4); 
            border: 1px solid #fff;
        }
        
        /* --- CROSSFADER SPECIFIC STYLES --- */
        .crossfader-rail {
            position: relative; 
            height: 15px; 
            background-color: var(--fader-rail); 
            border-radius: 8px;
            width: 100%;
            margin-top: 5px; 
            box-shadow: var(--box-shadow-inset); 
        }
        .crossfader-handle {
            position: absolute;
            top: -5px; 
            width: 30px; 
            height: 25px; 
            background-color: #E2E8F0; 
            border: 1px solid #fff; 
            border-radius: 4px;
            cursor: grab;
            transition: left 0.05s ease-out; 
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.8), 
                        0 0 1px #fff, 
                        inset 1px 1px 3px rgba(255, 255, 255, 0.4); 
        }
        .crossfader-handle:active {
            cursor: grabbing;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5); 
        }

        /* --- PLAY/CUE/STOP BUTTON STYLES --- */
        .btn {
            padding: 8px 12px; 
            border-radius: 6px; 
            font-weight: 900;
            color: #111827; 
            text-transform: uppercase;
            font-size: 11px;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.8); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            transition: all 0.1s;
        }

        .play-btn { background-color: #10B981; }
        .stop-btn { background-color: #EF4444; }
        .cue-btn  { background-color: #FBBF24; }

        .btn:active {
            box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.8); 
            transform: translateY(1px);
        }
        .cue-btn.active {
            background-color: #D97706;
            box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.8); 
            transform: translateY(1px);
        }
        
        .controls-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .controls-row button { flex-grow: 1; }
        .status-light { flex-shrink: 0; margin-left: 0; }

        /* --- HORIZONTAL VOLUME GROUP STYLES --- */
        .horizontal-fader-group {
            display: flex;
            justify-content: space-between;
            align-items: flex-end; 
            width: 100%;
            margin-bottom: 0; 
        }
        .master-hp-fader-group {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            margin-bottom: 0; 
        }
        .fader-control-horizontal {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 30%; 
        }
        .fader-control-horizontal input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        /* --- VU METER STYLES --- */
        .master-controls-group {
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: flex-end; 
            gap: 5px; 
            margin-bottom: 0; 
        }
        .vu-meter {
            display: flex;
            flex-direction: column-reverse; 
            width: 15px;
            height: 50px; 
            background-color: #020617;
            border: 1px solid #475569;
            border-radius: 4px;
            padding: 2px;
        }
        .vu-segment {
            height: 10%;
            margin-bottom: 1px;
            background-color: #38BDF8; 
            opacity: 0.2; 
            transition: opacity 0.1s;
        }
        .vu-segment.on { opacity: 1; }
        .vu-segment.yellow { background-color: #FACC15; }
        .vu-segment.red    { background-color: #EF4444; }
        .hp-mix-control {
            width: 100%;
            margin-top: 0; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .hp-mix-labels {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 8px;
            color: var(--control-label);
            margin-top: 3px;
        }
        
        .fx-panel-top, .fx-panel { margin-bottom: 0; }
        .fx-control { margin-top: 5px; }
    </style>

    <!-- Stylus add-on (triangle only, nudged right, nudged down a few px) -->
    <style id="stylus-addon">
      /* Triangle-only stylus near the 3 o'clock, slightly below centerline */
      .stylus-slider{
        position:absolute;
        top:calc(50% + 4px);   /* DOWN a few pixels */
        right:-6px;            /* small right nudge */
        transform:translateY(-50%);
        height:20px;
        pointer-events:none;
        z-index:10;
      }
      /* No rail */
      .stylus-hitbox{
        position:absolute;top:-6px;width:24px;height:20px;
        pointer-events:auto;cursor:ew-resize;
      }
      .stylus-handle{
        position:absolute;left:0;top:0;width:0;height:0;
        border-left:8px solid transparent;border-right:8px solid transparent;
        border-bottom:12px solid #38BDF8;
        filter:drop-shadow(0 0 2px rgba(56,189,248,.6));
      }
    </style>
</head>
<body>
    <div class="dj-container">

        <div id="fileLoader">
            <h1 class="app-title">SCRATCHER</h1>
            <div class="file-loader-group">
                <label for="musicFiles" class="text-sm font-semibold text-sky-400">
                    LOAD YOUR MUSIC FOLDERS:
                </label>
                <input type="file" id="musicFiles" multiple webkitdirectory directory style="display: none;">
                <button id="loadFilesBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-1 px-3 rounded text-xs transition duration-150">
                    Select Folders
                </button>
            </div>
            <div id="loadingStatus" class="text-xs mt-2 text-gray-300 w-full text-right">
                0 files loaded.
            </div>
        </div>

        <div class="main-mix">
            <div class="turntable" id="deckA">
                
                <div class="eq-section">
                    <div class="eq-knob">
                        <label class="eq-label">LOW</label>
                        <input type="range" id="eqLowA" min="-12" max="12" step="0.1" value="0.0">
                    </div>
                    <div class="eq-knob">
                        <label class="eq-label">MID</label>
                        <input type="range" id="eqMidA" min="-12" max="12" step="0.1" value="0.0">
                    </div>
                    <div class="eq-knob">
                        <label class="eq-label">HIGH</label>
                        <input type="range" id="eqHighA" min="-12" max="12" step="0.1" value="0.0">
                    </div>
                </div>

                <div class="track-display-window" id="statusA">---</div>

                <div class="record-plate">
                    <div class="record" id="recordA">
                        <div class="record-label">A</div>
                        <div class="cue-mark"></div>
                    </div>
                </div>
                
                <div class="deck-controls">
                    <select class="track-select" id="trackSelectA">
                        <option value="-1" disabled selected>SELECT TRACK</option>
                    </select>
                    <div class="controls-row">
                        <button class="btn play-btn" id="playA">PLAY</button>
                        <button class="btn cue-btn" id="cueA">CUE</button>
                        <button class="btn stop-btn" id="stopA">STOP</button>
                        <div class="status-light" id="lightA"></div>
                    </div>
                    <label class="fader-label text-center">PITCH</label>
                    <input type="range" id="pitchA" min="0.5" max="1.5" step="0.01" value="1.0">
                </div>
            </div>

            <div class="mixer">

                <div class="horizontal-fader-group">
                    <div class="fader-control-horizontal">
                        <label class="fader-label">VOL A</label>
                        <input type="range" id="volA" min="0" max="1" step="0.01" value="0.7">
                    </div>

                    <div class="master-controls-group">
                        <label class="fader-label">OUTPUT</label>
                        <div class="vu-meter" id="masterVUMeter">
                            <div class="vu-segment" style="height: 10%;" data-level="1"></div>
                            <div class="vu-segment" style="height: 10%;" data-level="2"></div>
                            <div class="vu-segment" style="height: 10%;" data-level="3"></div>
                            <div class="vu-segment" style="height: 10%;" data-level="4"></div>
                            <div class="vu-segment" style="height: 10%;" data-level="5"></div>
                            <div class="vu-segment" style="height: 10%;" data-level="6"></div>
                            <div class="vu-segment yellow" style="height: 10%;" data-level="7"></div>
                            <div class="vu-segment yellow" style="height: 10%;" data-level="8"></div>
                            <div class="vu-segment red" style="height: 10%;" data-level="9"></div>
                            <div class="vu-segment red" style="height: 10%;" data-level="10"></div>
                        </div>
                    </div>
                    
                    <div class="fader-control-horizontal">
                        <label class="fader-label">VOL B</label>
                        <input type="range" id="volB" min="0" max="1" step="0.01" value="0.7">
                    </div>
                </div>

                <div class="master-hp-fader-group">
                    <div class="fader-control-horizontal" style="width: 45%;">
                        <label class="fader-label">MASTER VOL</label>
                        <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.9">
                    </div>
                    <div class="fader-control-horizontal" style="width: 45%;">
                        <label class="fader-label">HP VOL</label>
                        <input type="range" id="hpVol" min="0" max="1" step="0.01" value="0.8">
                    </div>
                </div>
                
                <div class="hp-mix-control">
                    <label class="fader-label text-xs">HP CUE / MASTER</label>
                    <input type="range" id="hpMix" min="0" max="1" step="0.01" value="0.5" title="Headphone Cue/Master Mix">
                    <div class="hp-mix-labels">
                        <span>CUE</span>
                        <span>MASTER</span>
                    </div>
                </div>

                <div class="fx-panel-top">
                    <label class="fader-label text-xs">EFFECTS WET/DRY</label>

                    <div class="fx-control">
                        <input type="range" id="reverbWetDry" min="0" max="1" step="0.01" value="0.0" title="Reverb Wet/Dry">
                        <label class="fader-label text-xs">REVERB</label>
                    </div>
                    <div class="fx-control">
                        <input type="range" id="delayWetDry" min="0" max="1" step="0.01" value="0.0" title="Delay Wet/Dry">
                        <label class="fader-label text-xs">DELAY</label>
                    </div>
                </div>
                
                
                <div class="fx-panel">
                    <label class="fader-label text-xs">MASTER CHAIN</label>
                    
                    <div class="fx-control">
                        <input type="range" id="masterFilterFreq" min="100" max="18000" step="10" value="18000" title="Low Pass Filter Frequency">
                        <label class="fader-label text-xs">FILTER (LPF)</label>
                    </div>
                    <div class="fx-control">
                        <input type="range" id="delayFeedback" min="0.1" max="0.9" step="0.01" value="0.3" title="Delay Feedback">
                        <label class="fader-label text-xs">FEEDBACK</label>
                    </div>
                    <div class="fx-control">
                        <input type="range" id="delayTime" min="0.05" max="0.5" step="0.01" value="0.3" title="Delay Time">
                        <label class="fader-label text-xs">TIME</label>
                    </div>
                </div>

                <div class="crossfader-rail" id="crossfaderRail">
                    <div class="crossfader-handle" id="crossfaderHandle"></div>
                </div>
                <label class="fader-label">X-FADER</label>
                
            </div>

            <div class="turntable" id="deckB">
                
                <div class="eq-section">
                    <div class="eq-knob">
                        <label class="eq-label">LOW</label>
                        <input type="range" id="eqLowB" min="-12" max="12" step="0.1" value="0.0">
                    </div>
                    <div class="eq-knob">
                        <label class="eq-label">MID</label>
                        <input type="range" id="eqMidB" min="-12" max="12" step="0.1" value="0.0">
                    </div>
                    <div class="eq-knob">
                        <label class="eq-label">HIGH</label>
                        <input type="range" id="eqHighB" min="-12" max="12" step="0.1" value="0.0">
                    </div>
                </div>

                <div class="track-display-window" id="statusB">---</div>

                <div class="record-plate">
                    <div class="record" id="recordB">
                        <div class="record-label">B</div>
                        <div class="cue-mark"></div>
                    </div>
                </div>
                
                <div class="deck-controls">
                    <select class="track-select" id="trackSelectB">
                        <option value="-1" disabled selected>SELECT TRACK</option>
                    </select>
                    <div class="controls-row">
                        <button class="btn play-btn" id="playB">PLAY</button>
                        <button class="btn cue-btn" id="cueB">CUE</button>
                        <button class="btn stop-btn" id="stopB">STOP</button>
                        <div class="status-light" id="lightB"></div>
                    </div>
                    <label class="fader-label text-center">PITCH</label>
                    <input type="range" id="pitchB" min="0.5" max="1.5" step="0.01" value="1.0">
                </div>
            </div>
        </div>
    </div>
    <script>
        // --- JavaScript (Functional code for audio and interaction) ---
        let TRACKS = [];
        let audioCtx;
        let animationFrameId;
        let crossfaderGainA, crossfaderGainB, masterFilter, delayNode, feedbackGain, delayWetGain, reverbWetGain, reverbDelay, reverbLowPass, cueGain, masterOutGain;
        let masterVolGain;
        let masterPreListen; // Node for Master signal split to headphones
        let analyserNode; // For VU Meter

        const DECK_A = {
            id: 'A',
            trackIndex: -1,
            buffer: null,
            source: null,
            gain: null,
            rate: null,
            isPlaying: false,
            playbackPos: 0,
            lastUpdateTime: 0,
            currentRotation: 0,
            rotationStartClientX: 0,
            eq: { low: null, mid: null, high: null, scratch: null },
            isCueing: false,
            cueNode: null,
            hasMoved: false
        };
        const DECK_B = {
            id: 'B',
            trackIndex: -1,
            buffer: null,
            source: null,
            gain: null,
            rate: null,
            isPlaying: false,
            playbackPos: 0,
            lastUpdateTime: 0,
            currentRotation: 0,
            rotationStartClientX: 0,
            eq: { low: null, mid: null, high: null, scratch: null },
            isCueing: false,
            cueNode: null,
            hasMoved: false
        };

        const $ = id => document.getElementById(id);

        const decks = {
            A: {
                state: DECK_A,
                recordEl: $('recordA'),
                trackSelectEl: $('trackSelectA'),
                playBtn: $('playA'),
                stopBtn: $('stopA'),
                cueBtn: $('cueA'),
                light: $('lightA'),
                status: $('statusA'),
                pitch: $('pitchA'),
                vol: $('volA'),
                eqLow: $('eqLowA'),
                eqMid: $('eqMidA'),
                eqHigh: $('eqHighA')
            },
            B: {
                state: DECK_B,
                recordEl: $('recordB'),
                trackSelectEl: $('trackSelectB'),
                playBtn: $('playB'),
                stopBtn: $('stopB'),
                cueBtn: $('cueB'),
                light: $('lightB'),
                status: $('statusB'),
                pitch: $('pitchB'),
                vol: $('volB'),
                eqLow: $('eqLowB'),
                eqMid: $('eqMidB'),
                eqHigh: $('eqHighB')
            },
        };

        const crossfaderHandle = $('crossfaderHandle');
        const crossfaderRail = $('crossfaderRail');
        const delayWetDryControl = $('delayWetDry');
        const reverbWetDryControl = $('reverbWetDry');
        const delayFeedbackControl = $('delayFeedback');
        const delayTimeActualControl = $('delayTime');
        const masterFilterFreq = $('masterFilterFreq');
        const hpVolControl = $('hpVol');
        const musicFilesInput = $('musicFiles');
        const loadFilesBtn = $('loadFilesBtn');
        const loadingStatus = $('loadingStatus');
        const masterVolControl = $('masterVol');
        const masterVUMeter = $('masterVUMeter');
        const hpMixControl = $('hpMix');
        const vuSegments = Array.from(masterVUMeter.querySelectorAll('.vu-segment'));

        const BLANK_DISPLAY_TEXT = '---';
        const RECORD_PADDING_PERCENT = 0.1; // 10% inner and outer groove area for position jump

        /* ---------- STYLUS handled by injected script at end ---------- */

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // --- CUE CHAIN ---
            cueGain = audioCtx.createGain();
            cueGain.gain.value = parseFloat(hpVolControl.value);
            cueGain.connect(audioCtx.destination);

            masterPreListen = audioCtx.createGain(); // Master signal split for headphones
            updateHPMix(parseFloat(hpMixControl.value));
            masterPreListen.connect(cueGain);

            // --- MASTER CHAIN ---
            masterOutGain = audioCtx.createGain();
            masterOutGain.gain.value = 1.0;
            
            masterVolGain = audioCtx.createGain();
            masterVolGain.gain.value = parseFloat(masterVolControl.value);

            masterFilter = audioCtx.createBiquadFilter();
            masterFilter.type = 'lowpass';
            masterFilter.frequency.value = parseFloat(masterFilterFreq.value);
            masterFilter.Q.value = 0.5;

            // --- EFFECTS CHAIN ---
            delayNode = audioCtx.createDelay(1.0);
            delayNode.delayTime.value = parseFloat(delayTimeActualControl.value);
            
            feedbackGain = audioCtx.createGain();
            feedbackGain.gain.value = parseFloat(delayFeedbackControl.value);

            delayWetGain = audioCtx.createGain();
            delayWetGain.gain.value = 0.0;
            
            // Reverb (Simple faux reverb)
            reverbLowPass = audioCtx.createBiquadFilter();
            reverbLowPass.type = 'lowpass';
            reverbLowPass.frequency.value = 4000;
            reverbLowPass.Q.value = 0.5;

            reverbDelay = audioCtx.createDelay(0.3);
            reverbDelay.delayTime.value = 0.05;

            reverbWetGain = audioCtx.createGain();
            reverbWetGain.gain.value = 0.0;

            // Delay Feedback Loop
            delayNode.connect(feedbackGain);
            feedbackGain.connect(delayNode);
            delayNode.connect(delayWetGain);

            // Reverb Effect chain
            masterFilter.connect(reverbDelay);
            reverbDelay.connect(reverbLowPass);
            reverbLowPass.connect(reverbWetGain);
            
            // --- CUE/MASTER/DELAY/REVERB CONNECTS ---
            masterOutGain.connect(delayNode);
            masterOutGain.connect(masterFilter);

            masterFilter.connect(masterVolGain);
            delayWetGain.connect(masterVolGain);
            reverbWetGain.connect(masterVolGain);

            masterVolGain.connect(audioCtx.destination);
            masterVolGain.connect(masterPreListen);

            // --- VU METER ANALYSER ---
            analyserNode = audioCtx.createAnalyser();
            analyserNode.fftSize = 256;
            masterVolGain.connect(analyserNode);

            // --- DECK A & B INITIALIZATION ---
            crossfaderGainA = audioCtx.createGain();
            crossfaderGainB = audioCtx.createGain();

            initDeckAudio(DECK_A, crossfaderGainA);
            initDeckAudio(DECK_B, crossfaderGainB);

            crossfaderGainA.connect(masterOutGain);
            crossfaderGainB.connect(masterOutGain);

            // Set initial crossfader value (middle)
            updateCrossfader(0.5);

            // Start the visual update loop
            requestAnimationFrame(update);
        }

        function initDeckAudio(deckState, crossfaderGain) {
            // Master Deck Gain (for volume fader)
            deckState.gain = audioCtx.createGain();
            deckState.gain.gain.value = parseFloat($('vol' + deckState.id).value);
            deckState.gain.connect(crossfaderGain);

            // CUE Pre-listen Node
            deckState.cueNode = audioCtx.createGain();
            deckState.cueNode.gain.value = 0.0; // Start muted
            deckState.cueNode.connect(cueGain);

            // EQ Setup
            const eqLow = audioCtx.createBiquadFilter();
            eqLow.type = 'lowshelf';
            eqLow.frequency.value = 320;
            eqLow.gain.value = parseFloat($('eqLow' + deckState.id).value);

            const eqMid = audioCtx.createBiquadFilter();
            eqMid.type = 'peaking';
            eqMid.frequency.value = 1000;
            eqMid.Q.value = 1.0;
            eqMid.gain.value = parseFloat($('eqMid' + deckState.id).value);

            const eqHigh = audioCtx.createBiquadFilter();
            eqHigh.type = 'highshelf';
            eqHigh.frequency.value = 3200;
            eqHigh.gain.value = parseFloat($('eqHigh' + deckState.id).value);

            // Scratch Filter (Highpass used when scratching to remove bass rumble)
            const scratchFilter = audioCtx.createBiquadFilter();
            scratchFilter.type = 'highpass';
            scratchFilter.frequency.value = 20; // Default low
            scratchFilter.Q.value = 1.0;

            deckState.eq = { low: eqLow, mid: eqMid, high: eqHigh, scratch: scratchFilter };

            // Deck Audio Path: Source -> EQ Chain -> Scratch Filter -> Gain (Volume)
            eqLow.connect(eqMid);
            eqMid.connect(eqHigh);
            eqHigh.connect(scratchFilter);
            scratchFilter.connect(deckState.gain);

            // Connect EQ output to the cue node as well
            scratchFilter.connect(deckState.cueNode);
        }

        function loadTrack(files) {
            TRACKS = [];
            loadingStatus.textContent = 'Loading...';
            musicFilesInput.files = files;

            const filePromises = Array.from(files)
                .filter(file => file.type.startsWith('audio/'))
                .map(file => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            audioCtx.decodeAudioData(e.target.result, buffer => {
                                TRACKS.push({
                                    fileName: file.name,
                                    buffer: buffer
                                });
                                resolve();
                            }, reject);
                        };
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(file);
                    });
                });

            Promise.all(filePromises)
                .then(() => {
                    loadingStatus.textContent = `${TRACKS.length} files loaded.`;
                    populateTrackSelects();
                })
                .catch(error => {
                    console.error("Error loading files:", error);
                    loadingStatus.textContent = 'Error loading files.';
                });
        }

        function populateTrackSelects() {
            const selectA = decks.A.trackSelectEl;
            const selectB = decks.B.trackSelectEl;

            [selectA, selectB].forEach(select => {
                select.innerHTML = '<option value="-1" disabled selected>SELECT TRACK</option>';
                
                TRACKS.forEach((track, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = track.fileName;
                    select.appendChild(option);
                });
            });
        }

        function loadDeck(deckId, trackIndex) {
            const deck = decks[deckId];
            const deckState = deck.state;

            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }

            if (trackIndex === -1 || trackIndex >= TRACKS.length) {
                deckState.trackIndex = -1;
                deckState.buffer = null;
                deck.status.textContent = BLANK_DISPLAY_TEXT;
                deck.light.classList.remove('active');
                return;
            }

            const track = TRACKS[trackIndex];
            deckState.trackIndex = trackIndex;
            deckState.buffer = track.buffer;
            deckState.playbackPos = 0;
            deckState.currentRotation = 0;
            deck.status.textContent = track.fileName.substring(0, 30);
            deck.light.classList.remove('active');
            
            updatePitch(deckId, parseFloat(deck.pitch.value));
        }

        function playDeck(deckId) {
            const deck = decks[deckId];
            const deckState = deck.state;
            
            if (!deckState.buffer) return;

            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }

            const newSource = audioCtx.createBufferSource();
            newSource.buffer = deckState.buffer;

            newSource.connect(deckState.eq.low);

            newSource.playbackRate.value = deckState.rate || 1.0;
            deckState.rateNode = newSource.playbackRate;

            deckState.source = newSource;
            deckState.isPlaying = true;
            deckState.lastUpdateTime = audioCtx.currentTime;

            newSource.start(0, deckState.playbackPos);
            deck.light.classList.add('active');

            newSource.onended = () => {
                if (deckState.isPlaying && !deckState.isCueing) {
                    stopDeck(deckId);
                }
            };
        }

        function stopDeck(deckId) {
            const deck = decks[deckId];
            const deckState = deck.state;

            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }
            deckState.isPlaying = false;
            deckState.playbackPos = 0;
            deckState.currentRotation = 0;
            deck.light.classList.remove('active');
        }

        function cueDeck(deckId) {
            const deck = decks[deckId];
            const deckState = deck.state;

            if (!deckState.buffer) return;

            if (deckState.isCueing) {
                deckState.isCueing = false;
                deck.cueBtn.classList.remove('active');
                if (deckState.source) {
                    deckState.source.stop();
                    deckState.source.disconnect();
                    deckState.source = null;
                }
                deckState.cueNode.gain.value = 0.0;
                deckState.gain.gain.value = 0.0; 
                return;
            }

            deckState.isCueing = true;
            deck.cueBtn.classList.add('active');
            
            deckState.gain.gain.value = 0.0; 
            deckState.cueNode.gain.value = 1.0;

            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }

            deckState.playbackPos = 0; 
            
            const newSource = audioCtx.createBufferSource();
            newSource.buffer = deckState.buffer;
            newSource.connect(deckState.eq.low);
            newSource.playbackRate.value = deckState.rate || 1.0;
            deckState.rateNode = newSource.playbackRate;

            deckState.source = newSource;
            deckState.isPlaying = true;
            deckState.lastUpdateTime = audioCtx.currentTime;

            newSource.start(0, deckState.playbackPos);

            newSource.onended = () => {
                if (deckState.isCueing) {
                    stopDeck(deckId); 
                    deckState.isCueing = false;
                    deck.cueBtn.classList.remove('active');
                    deckState.cueNode.gain.value = 0.0;
                }
            };
        }

        function updateDeckTime(deckState) {
            if (!deckState.isPlaying || !deckState.buffer) return;

            const timeElapsed = audioCtx.currentTime - deckState.lastUpdateTime;
            deckState.lastUpdateTime = audioCtx.currentTime;

            const rate = deckState.rateNode ? deckState.rateNode.value : 1.0;
            deckState.playbackPos = (deckState.playbackPos + timeElapsed * rate) % deckState.buffer.duration;
            if (deckState.playbackPos < 0) {
                deckState.playbackPos += deckState.buffer.duration;
            }
        }

        function updatePitch(deckId, value) {
            const deckState = decks[deckId].state;
            deckState.rate = value;
            if (deckState.source) {
                deckState.rateNode.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
            }
        }

        function updateVolume(deckId, value) {
            const deckState = decks[deckId].state;
            if (!deckState.isCueing) {
                deckState.gain.gain.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
            }
        }

        function updateEQ(deckId, filterType, value) {
            const deckState = decks[deckId].state;
            deckState.eq[filterType].gain.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
        }

        function updateMasterVol(value) {
            masterVolGain.gain.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
        }

        function updateHPMix(value) {
            const masterVol = value;
            masterPreListen.gain.value = masterVol;
        }

        function updateCrossfader(value) {
            const aGain = Math.cos(value * 0.5 * Math.PI);
            const bGain = Math.cos((1.0 - value) * 0.5 * Math.PI);

            crossfaderGainA.gain.value = aGain;
            crossfaderGainB.gain.value = bGain;
        }

        function updateFilterFreq(value) {
            masterFilter.frequency.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
        }

        function updateDelayFeedback(value) {
            feedbackGain.gain.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
        }

        function updateDelayTime(value) {
            delayNode.delayTime.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
        }

        function updateFXWetDry(fx, value) {
            if (fx === 'delay') {
                delayWetGain.gain.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
            } else if (fx === 'reverb') {
                reverbWetGain.gain.linearRampToValueAtTime(value, audioCtx.currentTime + 0.05);
            }
        }

        function updateVUMeter() {
            if (!analyserNode) return;
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyserNode.getByteFrequencyData(dataArray);

            let sum = 0;
            for(let i = 0; i < bufferLength; i++) {
                sum += dataArray[i] * i;
            }
            const norm = Math.min(10, Math.max(0, Math.ceil(sum / (bufferLength * 100))));
    
            vuSegments.forEach((segment, index) => {
                const segmentLevel = 10 - index; 
                if (segmentLevel <= norm) {
                    segment.classList.add('on');
                } else {
                    segment.classList.remove('on');
                }
            });
        }

        function update() {
            updateDeckTime(DECK_A);
            updateDeckTime(DECK_B);
            updateRecordRotation(DECK_A);
            updateRecordRotation(DECK_B);
            updateVUMeter();
            animationFrameId = requestAnimationFrame(update);
        }

        function updateRecordRotation(deckState) {
            if (!deckState.buffer) return;
            
            let rate = 0;
            if (deckState.isDragging) {
                rate = deckState.scratchRate;
            } else if (deckState.isPlaying) {
                rate = deckState.rateNode ? deckState.rateNode.value : 1.0;
            }
            
            const rotationSpeed = rate * 360; 
            const timeDelta = (audioCtx.currentTime - deckState.lastUpdateTime);

            if(rate !== 0) {
                deckState.currentRotation += rotationSpeed * timeDelta;
                deckState.currentRotation %= 360; 
            }
            
            const deck = decks[deckState.id].recordEl;
            deck.style.transform = `rotate(${deckState.currentRotation}deg)`;
        }

        // --- Click-to-jump on record ---
        function jumpToPosition(deckId, e) {
            const deck = decks[deckId];
            const deckState = deck.state;
            const recordEl = deck.recordEl;

            if (!deckState.buffer) return;

            const rect = recordEl.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const radius = rect.width / 2;

            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY);

            const dx = clientX - centerX;
            const dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            let normalizedDistance = distance / radius;
            
            const PADDING = RECORD_PADDING_PERCENT;
            let trackPercentage = (normalizedDistance - PADDING) / (1 - 2 * PADDING);
            trackPercentage = Math.max(0, Math.min(1, trackPercentage)); 

            const newPos = trackPercentage * deckState.buffer.duration;
            deckState.playbackPos = newPos;

            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }
            
            const newSource = audioCtx.createBufferSource();
            newSource.buffer = deckState.buffer;
            newSource.connect(deckState.eq.low);
            newSource.playbackRate.value = deckState.rate || 1.0; 
            deckState.rateNode = newSource.playbackRate;

            deckState.source = newSource;
            deckState.isPlaying = true;
            deckState.lastUpdateTime = audioCtx.currentTime;

            newSource.start(0, deckState.playbackPos);
            
            newSource.onended = () => {
                if (deckState.isPlaying && !deckState.isCueing) {
                    stopDeck(deckId);
                }
            };

            if (!deckState.isCueing) {
                deck.light.classList.add('active');
            }
        }

        // --- INTERACTION HANDLERS (Scratching) ---
        let activeDeck = null;

        function handleStart(e, deckId) {
            e.preventDefault();
            initAudio();

            const deck = decks[deckId];
            const deckState = deck.state;

            if (!deckState.buffer) return;

            deckState.isDragging = true;
            activeDeck = deck;
            deckState.hasMoved = false; 
            
            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }

            deckState.rotationStartClientX = e.clientX || e.touches[0].clientX;
            deckState.scratchRate = 0;
            
            deckState.eq.scratch.frequency.linearRampToValueAtTime(6000, audioCtx.currentTime + 0.01);

            const newSource = audioCtx.createBufferSource();
            newSource.buffer = deckState.buffer;
            newSource.connect(deckState.eq.low);
            newSource.playbackRate.value = 0; 
            deckState.rateNode = newSource.playbackRate;

            deckState.source = newSource;
            deckState.isPlaying = true; 
            deckState.lastUpdateTime = audioCtx.currentTime;

            newSource.start(0, deckState.playbackPos);
        }

        function handleMove(e) {
            if (!activeDeck || !activeDeck.state.isDragging) return;
            e.preventDefault();

            const deck = activeDeck;
            const deckState = deck.state;

            const clientX = e.clientX || (e.touches.length > 0 ? e.touches[0].clientX : null);
            if (clientX === null) return;
            
            deckState.hasMoved = true; 

            const diffX = clientX - deckState.rotationStartClientX;
            deckState.rotationStartClientX = clientX; 

            const sensitivity = 0.5;
            const rotationChange = diffX * sensitivity; 
            const rateChange = rotationChange / 360; 
            
            deckState.scratchRate = rateChange * 10; 
            deckState.currentRotation += rotationChange;
            deckState.currentRotation %= 360; 

            const playbackChange = rotationChange * deckState.buffer.duration * 0.0027777777777778; 
            deckState.playbackPos = (deckState.playbackPos + playbackChange) % deckState.buffer.duration;
            if (deckState.playbackPos < 0) {
                deckState.playbackPos += deckState.buffer.duration;
            }

            if (deckState.source) {
                deckState.rateNode.value = deckState.scratchRate;
            }
        }

        function handleEnd(deckId) {
            const deck = decks[deckId];
            const deckState = deck.state;

            if (!deckState.isDragging) return;

            deckState.isDragging = false;
            activeDeck = null;

            deckState.eq.scratch.frequency.linearRampToValueAtTime(20, audioCtx.currentTime + 0.1);

            if (!deckState.hasMoved) {
                return; 
            }
            
            if (deckState.source) {
                deckState.source.stop();
                deckState.source.disconnect();
                deckState.source = null;
            }
            
            const newSource = audioCtx.createBufferSource();
            newSource.buffer = deckState.buffer;
            newSource.connect(deckState.eq.low);
            newSource.playbackRate.value = deckState.rate || 1.0; 
            deckState.rateNode = newSource.playbackRate;

            deckState.source = newSource;
            deckState.isPlaying = true;
            deckState.lastUpdateTime = audioCtx.currentTime;

            newSource.start(0, deckState.playbackPos);

            newSource.onended = () => {
                if (deckState.isPlaying && !deckState.isCueing) {
                    stopDeck(deckId);
                }
            };
        }

        // --- EVENT LISTENERS ---
        loadFilesBtn.addEventListener('click', () => {
            musicFilesInput.click();
        });
        musicFilesInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadTrack(e.target.files);
            }
        });

        // Deck A Events
        decks.A.trackSelectEl.addEventListener('change', (e) => loadDeck('A', parseInt(e.target.value)));
        decks.A.playBtn.addEventListener('click', () => playDeck('A'));
        decks.A.stopBtn.addEventListener('click', () => stopDeck('A'));
        decks.A.cueBtn.addEventListener('click', () => cueDeck('A'));
        decks.A.pitch.addEventListener('input', (e) => updatePitch('A', parseFloat(e.target.value)));
        decks.A.vol.addEventListener('input', (e) => updateVolume('A', parseFloat(e.target.value)));
        decks.A.eqLow.addEventListener('input', (e) => updateEQ('A', 'low', parseFloat(e.target.value)));
        decks.A.eqMid.addEventListener('input', (e) => updateEQ('A', 'mid', parseFloat(e.target.value)));
        decks.A.eqHigh.addEventListener('input', (e) => updateEQ('A', 'high', parseFloat(e.target.value)));

        // Deck B Events
        decks.B.trackSelectEl.addEventListener('change', (e) => loadDeck('B', parseInt(e.target.value)));
        decks.B.playBtn.addEventListener('click', () => playDeck('B'));
        decks.B.stopBtn.addEventListener('click', () => stopDeck('B'));
        decks.B.cueBtn.addEventListener('click', () => cueDeck('B'));
        decks.B.pitch.addEventListener('input', (e) => updatePitch('B', parseFloat(e.target.value)));
        decks.B.vol.addEventListener('input', (e) => updateVolume('B', parseFloat(e.target.value)));
        decks.B.eqLow.addEventListener('input', (e) => updateEQ('B', 'low', parseFloat(e.target.value)));
        decks.B.eqMid.addEventListener('input', (e) => updateEQ('B', 'mid', parseFloat(e.target.value)));
        decks.B.eqHigh.addEventListener('input', (e) => updateEQ('B', 'high', parseFloat(e.target.value)));

        // Crossfader drag (mouse + touch)
        let isDraggingCrossfader = false;

        crossfaderHandle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDraggingCrossfader = true;
        });
        document.addEventListener('mouseup', () => { isDraggingCrossfader = false; });
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingCrossfader) return;
            const rect = crossfaderRail.getBoundingClientRect();
            let x = e.clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));
            const value = x / rect.width;
            updateCrossfader(value);
            crossfaderHandle.style.left = `${x - 15}px`; 
        });

        crossfaderHandle.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDraggingCrossfader = true;
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
            if (!isDraggingCrossfader || e.touches.length === 0) return;
            const rect = crossfaderRail.getBoundingClientRect();
            let x = e.touches[0].clientX - rect.left;
            x = Math.max(0, Math.min(x, rect.width));
            const value = x / rect.width;
            updateCrossfader(value);
            crossfaderHandle.style.left = `${x - 15}px`;
        }, { passive: false });
        document.addEventListener('touchend', () => { isDraggingCrossfader = false; });

        // Turntable listeners
        const turntableListeners = (deckId) => {
            const deckEl = decks[deckId].recordEl;
            deckEl.addEventListener('mousedown', (e) => handleStart(e, deckId));
            deckEl.addEventListener('touchstart', (e) => handleStart(e, deckId), { passive: false });
            deckEl.addEventListener('click', (e) => {
                if (!decks[deckId].state.hasMoved) {
                    jumpToPosition(deckId, e);
                }
            });
        };
        turntableListeners('A');
        turntableListeners('B');

        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('mouseup', () => { if (activeDeck) handleEnd(activeDeck.id); });
        document.addEventListener('touchend', () => { if (activeDeck) handleEnd(activeDeck.id); });

        document.body.addEventListener('click', initAudio, { once: true });
        document.body.addEventListener('touchstart', initAudio, { once: true });
    </script>

    <!-- Stylus add-on JS (triangle only; no rail; label safety gap) -->
    <script>
    (function(){
      var SAFE_GAP_PX = 6;    // shave a few px near the label so the tip never overlaps it

      function computeTravelPx(record){
        var w = record.clientWidth || record.getBoundingClientRect().width;
        var radius = w / 2;
        var label = record.querySelector('.record-label');
        var labelR = 0;
        if (label){
          var lw = label.clientWidth || label.getBoundingClientRect().width;
          labelR = lw / 2;
        }
        // Outer rim  label rim, minus small safety gap
        var span = Math.max(10, Math.floor((radius - labelR) - SAFE_GAP_PX));
        return span;
      }

      function createStylus(record){
        var label = record.querySelector('.record-label');
        if(!label) return;

        var slider=document.createElement('div');
        slider.className='stylus-slider';
        slider.style.width = computeTravelPx(record) + 'px';

        // TRIANGLE ONLY (no rail)
        var hit=document.createElement('div');
        hit.className='stylus-hitbox';
        var handle=document.createElement('div');
        handle.className='stylus-handle';
        hit.appendChild(handle);
        slider.appendChild(hit);
        record.appendChild(slider);

        var dragging=false, value=0; // 0=start (outer rim), 1=end (label rim)

        function render(){
          var w=slider.clientWidth, hw=24;
          var x=(1-value)*w - hw/2;
          if(x < -hw/2) x = -hw/2;
          if(x >  w - hw/2) x = w - hw/2;
          hit.style.left = x + 'px';
        }

        function apply(){
          var deckRoot = record.closest('[id^="deck"]');
          var deckId   = deckRoot ? deckRoot.id.replace('deck','').toUpperCase() : null;

          if (deckId && typeof decks !== 'undefined' && typeof audioCtx !== 'undefined'){
            var st = decks[deckId].state;
            if(!st || !st.buffer) return;

            if(st.source){ try{ st.source.stop(); st.source.disconnect(); }catch(e){} st.source=null; }

            if(value >= 0.999){
              if(typeof stopDeck === 'function') stopDeck(deckId);
              return;
            }

            st.playbackPos = value * st.buffer.duration;
            var src = audioCtx.createBufferSource();
            src.buffer = st.buffer;
            src.connect(st.eq.low);
            src.playbackRate.value = st.rate || 1.0;
            st.rateNode = src.playbackRate;
            st.source = src;
            st.isPlaying = true;
            st.lastUpdateTime = audioCtx.currentTime;
            src.start(0, st.playbackPos);
            src.onended = function(){
              if(st.isPlaying && !st.isCueing && typeof stopDeck === 'function'){
                stopDeck(deckId);
              }
            };
          } else {
            // fallback event (if audio not initialized yet)
            record.dispatchEvent(new CustomEvent('stylus-scrub', { detail: { fraction: value, element: record } }));
          }
        }

        function setFromPlayback(){
          try{
            var deckRoot = record.closest('[id^="deck"]');
            var deckId = deckRoot ? deckRoot.id.replace('deck','').toUpperCase() : null;
            if(deckId && typeof decks !== 'undefined'){
              var st = decks[deckId].state;
              if(st && st.buffer && !dragging){
                value = st.playbackPos / st.buffer.duration;
                render();
              }
            }
          }catch(e){}
        }

        function start(e){ e.preventDefault(); dragging=true; }
        function move(clientX){
          if(!dragging) return;
          var rect = slider.getBoundingClientRect();
          var x = Math.max(0, Math.min(clientX - rect.left, rect.width));
          value = 1 - (x / rect.width); // rightstart, leftend
          render();
        }
        function end(){ if(!dragging) return; dragging=false; apply(); }

        hit.addEventListener('mousedown', function(e){ start(e); });
        document.addEventListener('mousemove', function(e){ move(e.clientX); });
        document.addEventListener('mouseup', end);

        hit.addEventListener('touchstart', function(e){ start(e); }, { passive:false });
        document.addEventListener('touchmove', function(e){
          if(e.touches && e.touches.length){ move(e.touches[0].clientX); }
        }, { passive:false });
        document.addEventListener('touchend', end);

        // clicking the invisible slider area also jumps
        slider.addEventListener('click', function(e){
          var rect = slider.getBoundingClientRect();
          var x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
          value = 1 - (x / rect.width);
          render();
          apply();
        });

        // keep width correct on resize
        function resize(){ slider.style.width = computeTravelPx(record) + 'px'; render(); }
        window.addEventListener('resize', resize);

        function sync(){ setFromPlayback(); requestAnimationFrame(sync); }
        requestAnimationFrame(sync);
        render();
      }

      function boot(){
        document.querySelectorAll('.record').forEach(function(record){
          createStylus(record);
        });
      }
      if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); } else { boot(); }
    })();
    </script>
</body>
</html>
