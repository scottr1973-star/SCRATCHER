<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Scratcher Pro 2026 - Kit Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Inter:wght@500;700;900&display=swap');

    :root {
      --bg-deep: #050507;
      --border-subtle: rgba(255, 255, 255, 0.15);
      --accent-primary: #0ea5e9; 
      --accent-secondary: #f43f5e;
      --accent-tertiary: #10b981;
      --text-main: #f1f5f9;
      --text-muted: #94a3b8;
    }

    html, body { 
        width: 100%; height: 100%; margin: 0; padding: 0;
        overflow: hidden; 
        background-color: #000; 
        font-family: 'Inter', sans-serif;
        color: var(--text-main);
        -webkit-font-smoothing: antialiased;
        touch-action: none;
        display: flex; align-items: center; justify-content: center;
    }

    /* SCALER CONTAINER */
    #app-scaler {
      width: 1280px;  
      height: 900px; 
      position: relative;
      background-color: var(--bg-deep);
      background-image: radial-gradient(circle at center, #15151a 0%, #000 100%);
      transform-origin: center center;
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
      flex: 0 0 auto;
    }

    .dj-container {
      width: 100%; height: 100%;
      display: flex; flex-direction: column;
      padding: 20px; box-sizing: border-box;
    }

    /* HEADER */
    #fileLoader {
      flex: 0 0 55px;
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 20px; margin-bottom: 15px;
      background: #0a0a0c; border: 1px solid var(--border-subtle); border-radius: 8px;
    }
    .app-title { font-weight: 900; font-size: 26px; letter-spacing: -0.02em; }
    
    .mini-btn {
      background: linear-gradient(180deg, #2a2a30, #1a1a20);
      color: var(--text-main); font-size: 13px; font-weight: 700;
      padding: 8px 16px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);
      cursor: pointer; text-transform: uppercase; white-space: nowrap;
    }
    .mini-btn:hover { border-color: var(--accent-primary); color: #fff; }
    .mini-btn.red { background: linear-gradient(180deg, #7f1d1d, #450a0a); border-color: #991b1b; }
    .mini-btn.rec.active { background: #ef4444; box-shadow: 0 0 15px #ef4444; border-color:#fff; animation: pulse 1s infinite; }
    .mini-btn.midi.active { background: #eab308; color:#000; border-color:#fff; }
    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    /* MAIN LAYOUT */
    .main-mix {
      flex: 1; display: grid; 
      /* Wide Mixer for Sampler */
      grid-template-columns: 1fr 400px 1fr; 
      gap: 20px; 
      min-height: 0;
    }

    /* DECK PANEL */
    .turntable {
      background: linear-gradient(180deg, #25252b 0%, #15151a 100%);
      border: 1px solid var(--border-subtle); border-radius: 12px;
      padding: 15px;
      display: flex; flex-direction: column; gap: 8px;
      position: relative; overflow: hidden;
    }

    /* WAVEFORM */
    .waveform-display {
      height: 40px; 
      background: #000; border: 1px solid #333; border-radius: 4px;
      position: relative; overflow: hidden; margin-bottom: 2px;
    }
    .waveform-canvas { width: 100%; height: 100%; display: block; }
    .waveform-cursor { 
      position: absolute; left: 50%; top: 0; bottom: 0; width: 2px; background: #fff; 
      box-shadow: 0 0 5px #fff; z-index: 10;
    }

    /* DECK INFO */
    .deck-info-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px; }
    .bpm-box { font-family: 'JetBrains Mono', monospace; font-size: 22px; color: var(--accent-tertiary); font-weight: 900; background:#000; padding:2px 10px; border-radius:4px; border:1px solid #333; }
    .sync-btn { font-size:12px; font-weight:900; background:#333; color:#aaa; border:1px solid #555; padding:6px 12px; border-radius:4px; cursor:pointer; }
    .sync-btn.active { background:var(--accent-primary); color:#000; border-color:#fff; box-shadow:0 0 10px var(--accent-primary); }

    /* EQs & VUs */
    .eq-section { display: flex; gap: 10px; flex: 0 0 auto; margin-bottom: 5px; }
    .eq-knob { flex: 1; text-align: center; }

    /* HORIZONTAL DECK VU */
    .deck-vu-strip {
        width: 100%; height: 12px; background: #000; border: 1px solid #333; 
        display: flex; gap: 1px; padding: 1px; margin-bottom: 5px;
    }
    .deck-seg { flex: 1; background: #1a1a1a; height: 100%; }
    .deck-seg.on { background: #10b981; }
    .deck-seg.mid.on { background: #fbbf24; }
    .deck-seg.red.on { background: #ef4444; }

    /* RECORD (240px) */
    .record-container {
      flex: 1; display: flex; align-items: center; justify-content: center;
      min-height: 0; padding: 5px 0; position: relative;
    }
    .record-plate {
      width: 240px; height: 240px; 
      position: relative; border-radius: 50%; background: #080808;
      box-shadow: 0 8px 25px rgba(0,0,0,0.6), 0 0 0 5px #18181b, 0 0 0 6px #000;
      flex-shrink: 0;
    }
    .record {
      width: 100%; height: 100%; border-radius: 50%;
      background: repeating-radial-gradient(#111 0, #111 2px, #1a1a1a 3px, #1a1a1a 4px);
      position: relative; touch-action: none; cursor: grab; border: 2px solid #000;
    }
    .record-label {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 35%; height: 35%; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-weight: 900; font-size: 20px; color: #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.2);
      border: 4px solid rgba(0,0,0,0.1);
    }
    #deckA .record-label { background: var(--accent-secondary); }
    #deckB .record-label { background: var(--accent-primary); }
    .cue-mark {
      position: absolute; top: 5%; left: 50%; transform: translateX(-50%);
      width: 6%; height: 6%; border-radius: 50%; background: #fff; box-shadow: 0 0 10px #fff;
    }

    /* STYLUS */
    .stylus-slider {
      position: absolute; top: 50%; right: 0; height: 6px; background: rgba(255,255,255,0.1);
      transform: translateY(-50%); z-index: 10; pointer-events: none; border-radius: 3px;
    }
    .stylus-hitbox { position: absolute; top: -20px; width: 24px; height: 46px; pointer-events: auto; cursor: ew-resize; }
    .stylus-handle {
      width: 0; height: 0; 
      border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 24px solid var(--accent-primary);
      filter: drop-shadow(0 0 6px var(--accent-primary));
    }

    /* DECK CONTROLS */
    .deck-controls { flex: 0 0 auto; display: flex; flex-direction: column; gap: 8px; }
    .pads-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 4px; }
    .pad-btn {
      height: 36px; background: #1e1e24; border: 1px solid #333; border-radius: 4px; cursor: pointer;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .pad-btn:active { background: #333; }
    .pad-btn.set { background: var(--accent-primary); box-shadow: 0 0 8px var(--accent-primary); border-color:#fff; }

    .loops-row { display: flex; gap: 4px; margin-bottom: 5px; }
    .loop-btn {
      flex: 1; background: #111; color: #888; border: 1px solid #333; font-size: 10px; font-weight: 700; padding: 6px 0; cursor: pointer; border-radius: 3px;
    }
    .loop-btn.active { background: var(--accent-tertiary); color: #000; border-color: #fff; }

    .track-display-window {
      background: #000; border: 1px solid #333; border-radius: 4px; padding: 8px;
      font-family: 'JetBrains Mono', monospace; font-size: 13px; color: var(--accent-primary);
      text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.8);
    }
    .controls-row { display: flex; gap: 10px; }
    
    .btn {
      flex: 1; padding: 16px 0; border-radius: 6px; border: none;
      font-weight: 800; font-size: 14px; cursor: pointer;
      box-shadow: 0 4px 0 rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
      text-transform: uppercase;
    }
    .btn:active { transform: translateY(2px); box-shadow: inset 0 2px 5px rgba(0,0,0,0.6); }
    
    .play-btn { background: linear-gradient(180deg, #334155, #1e293b); color: #fff; border: 2px solid transparent; }
    .play-btn.playing { border: 2px solid #00ff00; background: #10b981; box-shadow: 0 0 15px #10b981; }
    .stop-btn { background: linear-gradient(180deg, #334155, #1e293b); color: #f87171; border: 2px solid transparent; }
    .cue-btn { background: linear-gradient(180deg, #334155, #1e293b); color: #fbbf24; border: 2px solid transparent; }
    .cue-btn.active { background: #fbbf24; color: #000; transform: translateY(2px); }

    /* HORIZONTAL VOLUME FADER */
    .vol-fader-container { width: 100%; padding: 5px 0; }
    input[type=range].horiz-fader {
        -webkit-appearance: none; width: 100%; background: transparent; cursor: grab; margin: 0;
    }
    input[type=range].horiz-fader::-webkit-slider-runnable-track {
        width: 100%; height: 10px; cursor: pointer; background: #050507; border-radius: 5px; border: 1px solid #333;
    }
    input[type=range].horiz-fader::-webkit-slider-thumb {
        -webkit-appearance: none; height: 26px; width: 40px; border-radius: 4px; 
        background: linear-gradient(180deg, #64748b 0%, #334155 50%, #1e293b 100%);
        border: 1px solid #000; margin-top: -9px; box-shadow: 0 2px 5px rgba(0,0,0,0.8);
    }

    /* MIXER */
    .mixer {
      background: #15151a; border: 1px solid var(--border-subtle); border-radius: 12px;
      padding: 20px; display: flex; flex-direction: column; justify-content: flex-start; gap: 15px;
    }

    label { font-size: 12px; font-weight: 800; color: #94a3b8; margin-bottom: 2px; display: block; text-transform: uppercase; letter-spacing: 0.05em; }
    .label-lg { font-size: 16px; font-weight:900; color: #fff; margin-bottom: 6px; }

    /* KNOBS */
    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; cursor: grab; margin: 0; }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #050507; border-radius: 3px; border: 1px solid #000; box-shadow: inset 0 2px 4px rgba(0,0,0,0.9); }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%; margin-top: -6px; background: radial-gradient(circle at 30% 30%, #e2e8f0 0%, #94a3b8 40%, #475569 100%); border: 1px solid #000; box-shadow: 0 4px 8px rgba(0,0,0,0.7); }

    /* FX RACK */
    .fx-rack {
        background: rgba(20,20,25,0.6); border:1px solid #444; border-radius:8px; padding:15px;
        display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%;
        flex: 0 0 auto;
    }
    .fx-knob-group { text-align: center; }

    /* MASTER VU */
    .master-vu-strip { width: 100%; height: 24px; background: #000; border: 1px solid #333; display: flex; gap: 1px; padding: 2px; margin-top: 5px; flex: 0 0 auto; }
    .m-seg { flex: 1; background: #1a1a1a; height: 100%; }
    .m-seg.on { background: #10b981; }
    .m-seg.mid.on { background: #fbbf24; }
    .m-seg.red.on { background: #ef4444; }

    /* SAMPLER BANK */
    .sampler-section { width: 100%; flex: 1; display:flex; flex-direction:column; justify-content:flex-end; padding-top:10px; min-height: 250px; }
    .sampler-header { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 5px; }
    .sampler-bank { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; width: 100%; height: 100%; }
    
    .sample-pad { 
        background: #2a2a30; color: #888; border: 1px solid #444; 
        font-weight: 700; font-size: 12px; cursor: pointer; border-radius: 6px; 
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: all 0.05s; overflow: hidden; position: relative; user-select: none; -webkit-user-select: none;
    }
    .sample-pad span { font-size: 9px; font-weight: normal; color: #555; margin-top: 4px; text-transform: uppercase; }
    .sample-pad:active { background: #fff; color: #000; }
    .sample-pad.loaded { border-color: var(--accent-primary); color: var(--accent-primary); background: rgba(14, 165, 233, 0.1); }
    .sample-pad.playing { background: var(--accent-primary); color: #000; box-shadow: 0 0 20px var(--accent-primary); border-color:#fff;}
    .sample-pad.recording { background: #ef4444 !important; color: #fff !important; box-shadow: 0 0 10px #ef4444; animation: pulse 0.5s infinite; }
    .sample-pad.armed { border: 2px dashed #fbbf24; color: #fbbf24; }

    /* CONTEXT MENU */
    #padMenu {
        position: absolute; display: none; background: rgba(20,20,25,0.95); backdrop-filter: blur(10px);
        border: 1px solid #444; border-radius: 6px; padding: 5px; z-index: 2000; min-width: 150px;
        box-shadow: 0 10px 20px rgba(0,0,0,0.8);
    }
    .menu-item {
        padding: 8px 12px; cursor: pointer; font-size: 12px; color: #fff; border-radius: 4px;
        transition: background 0.1s;
    }
    .menu-item:hover { background: var(--accent-primary); color: #000; font-weight: bold; }
    .menu-sep { height: 1px; background: #444; margin: 4px 0; }

    /* CROSSFADER */
    .crossfader-container { padding: 15px 0; flex: 0 0 auto; position: relative; z-index: 50; margin-top: 15px;}
    .crossfader-rail { height: 24px; background: #000; border-radius: 12px; position: relative; box-shadow: inset 0 2px 5px rgba(0,0,0,0.9), 0 1px 0 rgba(255,255,255,0.1); border: 1px solid #111; }
    .crossfader-touch-zone { position: absolute; top: -40px; bottom: -40px; left: -20px; right: -20px; z-index: 60; cursor: ew-resize; }
    .crossfader-handle { width: 70px; height: 50px; background: linear-gradient(180deg, #94a3b8, #475569); border-radius: 4px; position: absolute; top: -13px; left: 50%; transform: translateX(-50%); pointer-events:none; border-top: 1px solid rgba(255,255,255,0.4); border-bottom: 1px solid rgba(0,0,0,0.8); box-shadow: 0 6px 12px rgba(0,0,0,0.7); z-index: 55; }
    .crossfader-handle::after { content: ''; position: absolute; top: 14px; left: 25px; right: 25px; bottom: 14px; border-top: 2px solid rgba(0,0,0,0.3); border-bottom: 2px solid rgba(0,0,0,0.3); }

    #midiOverlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; }
    .midi-target { outline: 3px solid yellow !important; cursor: crosshair !important; z-index: 1000; }

  </style>
</head>
<body>

  <div id="padMenu">
      <div class="menu-item" onclick="handleMenu('load')">üìÇ Load Sample...</div>
      <div class="menu-item" onclick="handleMenu('rec')">üé§ Record Mic</div>
      <div class="menu-sep"></div>
      <div class="menu-item" onclick="handleMenu('oneshot')">Mode: One-Shot</div>
      <div class="menu-item" onclick="handleMenu('toggle')">Mode: Toggle</div>
      <div class="menu-item" onclick="handleMenu('loop')">Mode: Loop</div>
  </div>

  <div id="app-scaler">
    
    <div class="dj-container">
        
        <div id="fileLoader">
          <div style="display:flex; align-items:center; gap:15px;">
              <h1 class="app-title">SCRATCHER PRO <span style="font-weight:300; color:var(--accent-primary); font-size:0.6em;">ULTIMATE</span></h1>
              <div id="recTimer" style="font-family:'JetBrains Mono'; font-size:16px; color:#ef4444; visibility:hidden;">00:00</div>
          </div>
          <div style="display:flex; gap:12px; align-items:center;">
            <button id="midiBtn" class="mini-btn midi">MIDI LEARN</button>
            <button id="recBtn" class="mini-btn rec">‚óè REC</button>
            <div style="width:1px; height:20px; background:#444; margin:0 5px;"></div>
            <input type="file" id="musicFiles" multiple webkitdirectory directory style="display:none;">
            <input type="file" id="filePicker" multiple accept="audio/*" style="display:none;">
            <button id="loadFilesBtn" class="mini-btn">üìÅ Folder</button>
            <button id="addFilesBtn"  class="mini-btn">üìÑ Files</button>
            <div id="loadingStatus" class="text-xs text-gray-400 font-bold tracking-wide" style="font-size:14px;">EMPTY</div>
          </div>
        </div>

        <div class="main-mix">
          
          <div class="turntable" id="deckA">
            <div class="deck-info-row">
                <div style="display:flex; gap:10px; align-items:center;">
                    <div class="bpm-box" id="bpmA">0.0</div>
                    <button class="sync-btn" id="syncA">SYNC</button>
                </div>
                <div class="track-display-window" id="statusA" style="flex:1; margin-left:10px;">NO TRACK</div>
            </div>

            <div class="waveform-display">
                <canvas id="waveA" class="waveform-canvas"></canvas>
                <div class="waveform-cursor"></div>
            </div>
            
            <div class="eq-section">
              <div class="eq-knob"><label>HI</label><input type="range" id="eqHighA" min="-12" max="12" step="0.1" value="0.0"></div>
              <div class="eq-knob"><label>MID</label><input type="range" id="eqMidA" min="-12" max="12" step="0.1" value="0.0"></div>
              <div class="eq-knob"><label>LO</label><input type="range" id="eqLowA" min="-12" max="12" step="0.1" value="0.0"></div>
            </div>

            <div class="deck-vu-strip" id="vuA"></div>

            <div class="record-container">
              <div class="record-plate">
                <div class="record" id="recordA">
                  <div class="record-label">A</div>
                  <div class="cue-mark"></div>
                </div>
              </div>
            </div>

            <div class="deck-controls">
                <div class="pads-row">
                    <button class="pad-btn" id="hcA1" data-id="0"></button>
                    <button class="pad-btn" id="hcA2" data-id="1"></button>
                    <button class="pad-btn" id="hcA3" data-id="2"></button>
                    <button class="pad-btn" id="hcA4" data-id="3"></button>
                </div>
                <div class="loops-row">
                    <button class="loop-btn" id="loopInA">IN</button>
                    <button class="loop-btn" id="loopOutA">OUT</button>
                    <button class="loop-btn" id="loopExitA">EXIT</button>
                    <button class="loop-btn" id="loop4A">4</button>
                    <button class="loop-btn" id="loop8A">8</button>
                </div>

              <div style="display:flex; justify-content:space-between; align-items:center;">
                <label>PITCH</label>
                <input type="range" id="pitchA" min="0.5" max="1.5" step="0.001" value="1.0" style="width:70%">
              </div>
              <select id="trackSelectA" style="background:#111; color:#fff; border:1px solid #444; font-size:14px; padding:8px; border-radius:4px;"><option value="-1">Select Track</option></select>
              
              <div class="vol-fader-container">
                  <label>VOLUME</label>
                  <input type="range" id="volA" class="horiz-fader" min="0" max="1" step="0.01" value="0.8">
              </div>

              <div class="controls-row">
                <button class="btn play-btn" id="playA">PLAY</button>
                <button class="btn cue-btn"  id="cueA">CUE</button>
                <button class="btn stop-btn" id="stopA">STOP</button>
              </div>
            </div>
          </div>

          <div class="mixer">
            
            <div class="master-hp-row" style="display:flex; justify-content:space-between; gap:20px; flex:0 0 auto;">
              <div style="width:48%">
                <label class="label-lg">MASTER</label>
                <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.9">
              </div>
              <div style="width:48%">
                <label class="label-lg">PHONES</label>
                <input type="range" id="hpVol" min="0" max="1" step="0.01" value="0.8">
              </div>
            </div>

            <div class="fx-rack">
                <div class="fx-knob-group"><label class="label-lg">REVERB</label><input type="range" id="fxReverb" min="0" max="1" step="0.01" value="0"></div>
                <div class="fx-knob-group"><label class="label-lg">DELAY</label><input type="range" id="fxDelay" min="0" max="1" step="0.01" value="0"></div>
                <div class="fx-knob-group"><label class="label-lg">DRIVE</label><input type="range" id="fxDrive" min="0" max="1" step="0.01" value="0"></div>
                <div class="fx-knob-group"><label class="label-lg">FILTER</label><input type="range" id="masterFilterFreq" min="100" max="18000" step="10" value="18000"></div>
            </div>

            <div>
                <label style="text-align:center;">MASTER L/R</label>
                <div class="master-vu-strip" id="vuMasterL"></div>
                <div class="master-vu-strip" id="vuMasterR" style="margin-top:2px;"></div>
            </div>

            <div class="sampler-section">
                <div class="sampler-header">
                    <label style="margin:0;">16-PAD SAMPLER <span style="font-size:9px; font-weight:normal; text-transform:none;">Right-Click/Hold to Edit</span></label>
                    <div>
                        <button class="mini-btn" style="padding:4px 8px; font-size:10px;" onclick="saveKit()">SAVE KIT</button>
                        <button class="mini-btn" style="padding:4px 8px; font-size:10px;" onclick="$('kitInput').click()">LOAD KIT</button>
                        <input type="file" id="kitInput" style="display:none;" accept=".json">
                    </div>
                </div>
                <div class="sampler-bank" id="samplerGrid">
                    </div>
                <input type="file" id="sampleInput" style="display:none;" accept="audio/*">
            </div>

            <div class="crossfader-container">
              <label style="text-align:center; margin-bottom:8px; font-size:16px;">CROSSFADER</label>
              <div class="crossfader-rail" id="crossfaderRail">
                <div class="crossfader-touch-zone" id="xfTouch"></div>
                <div class="crossfader-handle" id="crossfaderHandle"></div>
              </div>
              <div style="display:flex; justify-content:space-between; padding-top:4px; font-size:14px; color:#555; font-weight:bold;">
                <span>A</span><span>B</span>
              </div>
            </div>
          </div>

          <div class="turntable" id="deckB">
            <div class="deck-info-row">
                <div style="display:flex; gap:10px; align-items:center;">
                    <div class="bpm-box" id="bpmB">0.0</div>
                    <button class="sync-btn" id="syncB">SYNC</button>
                </div>
                <div class="track-display-window" id="statusB" style="flex:1; margin-left:10px;">NO TRACK</div>
            </div>

            <div class="waveform-display">
                <canvas id="waveB" class="waveform-canvas"></canvas>
                <div class="waveform-cursor"></div>
            </div>
            
            <div class="eq-section">
              <div class="eq-knob"><label>HI</label><input type="range" id="eqHighB" min="-12" max="12" step="0.1" value="0.0"></div>
              <div class="eq-knob"><label>MID</label><input type="range" id="eqMidB" min="-12" max="12" step="0.1" value="0.0"></div>
              <div class="eq-knob"><label>LO</label><input type="range" id="eqLowB" min="-12" max="12" step="0.1" value="0.0"></div>
            </div>

            <div class="deck-vu-strip" id="vuB"></div>

            <div class="record-container">
              <div class="record-plate">
                <div class="record" id="recordB">
                  <div class="record-label">B</div>
                  <div class="cue-mark"></div>
                </div>
              </div>
            </div>

            <div class="deck-controls">
                <div class="pads-row">
                    <button class="pad-btn" id="hcB1" data-id="0"></button>
                    <button class="pad-btn" id="hcB2" data-id="1"></button>
                    <button class="pad-btn" id="hcB3" data-id="2"></button>
                    <button class="pad-btn" id="hcB4" data-id="3"></button>
                </div>
                <div class="loops-row">
                    <button class="loop-btn" id="loopInB">IN</button>
                    <button class="loop-btn" id="loopOutB">OUT</button>
                    <button class="loop-btn" id="loopExitB">EXIT</button>
                    <button class="loop-btn" id="loop4B">4</button>
                    <button class="loop-btn" id="loop8B">8</button>
                </div>

              <div style="display:flex; justify-content:space-between; align-items:center;">
                <label>PITCH</label>
                <input type="range" id="pitchB" min="0.5" max="1.5" step="0.001" value="1.0" style="width:70%">
              </div>
              <select id="trackSelectB" style="background:#111; color:#fff; border:1px solid #444; font-size:14px; padding:8px; border-radius:4px;"><option value="-1">Select Track</option></select>
              
              <div class="vol-fader-container">
                  <label>VOLUME</label>
                  <input type="range" id="volB" class="horiz-fader" min="0" max="1" step="0.01" value="0.8">
              </div>

              <div class="controls-row">
                <button class="btn play-btn" id="playB">PLAY</button>
                <button class="btn cue-btn"  id="cueB">CUE</button>
                <button class="btn stop-btn" id="stopB">STOP</button>
              </div>
            </div>
          </div>

        </div>
    </div>
  </div>

  <div id="midiOverlay" style="display:none;">
    <h1 style="font-size:40px; font-weight:900;">MIDI LEARN</h1>
    <p>Click a control, then move a knob/fader.</p>
    <button id="closeMidiBtn" class="mini-btn">CLOSE</button>
  </div>

  <script>
    /* --------- SCALE ENGINE --------- */
    (function(){
      const BASE_WIDTH = 1280;
      const BASE_HEIGHT = 900;
      const scaler = document.getElementById('app-scaler');
      function resizeApp(){
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const scale = Math.min(winW / BASE_WIDTH, winH / BASE_HEIGHT);
        scaler.style.transform = `scale(${scale})`;
      }
      window.addEventListener('resize', resizeApp);
      resizeApp();
    })();

    /* --------- AUDIO CORE --------- */
    let audioCtx;
    let masterGain, masterAnalyser, recDest, mediaRecorder, recChunks = [];
    let recStartTime;
    let TRACKS = [];
    const $ = id => document.getElementById(id);

    // FX
    let fxReverbNode, fxDelayNode, fxDriveNode, fxFilterNode;
    let fxBusGain, fxReverbGain, fxDelayGain;

    class Deck {
        constructor(id) {
            this.id = id;
            this.buffer = null;
            this.source = null;
            this.gain = null;
            this.analyser = null;
            this.eq = {}; 
            this.speed = 1.0;
            this.playbackPos = 0;
            this.lastTime = 0;
            this.isPlaying = false;
            this.bpm = 0;
            this.detectedBPM = 0;
            this.loopIn = -1; this.loopOut = -1; this.isLooping = false;
            this.hotCues = [null,null,null,null];
            this.isDragging = false;
            this.touchId = null; 
            this.angle = 0; this.startAngle = 0; this.baseAngle = 0; this.accumAngle = 0; this.startPlaybackPos = 0;
            this.wasPlaying = false; 
        }
    }
    const decks = { A: new Deck('A'), B: new Deck('B') };

    function initAudio(){
        if(audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        masterGain = audioCtx.createGain();
        masterAnalyser = audioCtx.createAnalyser();
        masterAnalyser.smoothingTimeConstant = 0.8;
        masterAnalyser.fftSize = 64;
        
        setupFX();

        // FX Routing
        fxReverbGain.connect(masterGain);
        fxDelayGain.connect(masterGain);
        
        masterGain.connect(masterAnalyser);
        masterAnalyser.connect(audioCtx.destination);
        
        recDest = audioCtx.createMediaStreamDestination();
        masterGain.connect(recDest);

        ['A','B'].forEach(id => initDeckChain(decks[id]));
        requestAnimationFrame(updateLoop);
    }

    function setupFX() {
        fxFilterNode = audioCtx.createBiquadFilter();
        fxFilterNode.type = 'lowpass';
        fxFilterNode.frequency.value = 20000;

        fxDriveNode = audioCtx.createWaveShaper();
        fxDriveNode.curve = makeDistortionCurve(0);
        
        fxDelayNode = audioCtx.createDelay(1.0);
        fxDelayNode.delayTime.value = 0.3;
        const delayFb = audioCtx.createGain();
        delayFb.gain.value = 0.4;
        fxDelayNode.connect(delayFb);
        delayFb.connect(fxDelayNode);
        
        fxReverbNode = audioCtx.createConvolver();
        const rate = audioCtx.sampleRate;
        const len = rate * 2.0; 
        const buff = audioCtx.createBuffer(2, len, rate);
        for(let c=0;c<2;c++){
            const d = buff.getChannelData(c);
            for(let i=0;i<len;i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 2);
        }
        fxReverbNode.buffer = buff;

        fxReverbGain = audioCtx.createGain(); fxReverbGain.gain.value=0;
        fxDelayGain = audioCtx.createGain(); fxDelayGain.gain.value=0;
        
        fxReverbNode.connect(fxReverbGain);
        fxDelayNode.connect(fxDelayGain);
    }
    
    function makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50;
        const n = 44100;
        const curve = new Float32Array(n);
        const deg = Math.PI / 180;
        for (let i = 0; i < n; ++i ) {
            let x = i * 2 / n - 1;
            curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
        }
        return curve;
    }

    /* --------- 16-PAD POLYPHONIC SAMPLER --------- */
    let samplerPads = Array(16).fill(null).map(()=>({ 
        buffer:null, name:'EMPTY', mode:'oneshot', playing:false 
    }));
    let activePadIndex = -1;
    let padRecorders = {};

    // Generate UI
    const grid = $('samplerGrid');
    for(let i=0; i<16; i++){
        const btn = document.createElement('button');
        btn.className = 'sample-pad';
        btn.id = `pad${i}`;
        btn.innerHTML = `${i+1}<span>EMPTY</span>`;
        
        // Touch/Click Play
        const hit = (e) => { 
            // Only trigger if NOT a right-click
            if(e.button !== 2) {
                e.preventDefault(); triggerPad(i); 
            }
        };
        btn.addEventListener('mousedown', hit);
        btn.addEventListener('touchstart', (e)=>{ 
            // LONG PRESS DETECTOR for Touch
            e.preventDefault(); 
            btn.dataset.longpress = setTimeout(()=>{
                showPadMenu({pageX: e.changedTouches[0].pageX, pageY: e.changedTouches[0].pageY}, i);
                btn.dataset.longpress = null; 
            }, 800); // 800ms hold = Right Click
            triggerPad(i); 
        }, {passive:false});

        btn.addEventListener('touchend', (e)=>{
            if(btn.dataset.longpress) {
                clearTimeout(btn.dataset.longpress);
                btn.dataset.longpress = null;
            }
        });
        
        // Context Menu (Right Click)
        btn.addEventListener('contextmenu', (e)=>{
            e.preventDefault();
            showPadMenu(e, i);
        });
        
        // Drag Drop
        btn.addEventListener('dragover', e=>e.preventDefault());
        btn.addEventListener('drop', e=>{
            e.preventDefault();
            const f = e.dataTransfer.files[0];
            if(f) loadSampleFile(f, i);
        });
        
        grid.appendChild(btn);
    }

    function triggerPad(idx) {
        if(!audioCtx) initAudio();
        const p = samplerPads[idx];
        const btn = $(`pad${idx}`);
        
        // Record Mode
        if(p.mode === 'record') {
            togglePadRecording(idx);
            return;
        }

        if(!p.buffer) return;

        // Toggle Mode Logic
        if(p.mode === 'toggle' && p.playing && p.source) {
            try { p.source.stop(); } catch(e){}
            p.playing = false;
            btn.classList.remove('playing');
            return;
        }

        // Play Sound
        const src = audioCtx.createBufferSource();
        src.buffer = p.buffer;
        src.connect(masterGain);
        src.start(0);
        
        if(p.mode === 'toggle') {
            p.source = src;
            p.playing = true;
            btn.classList.add('playing');
            src.onended = () => { p.playing = false; btn.classList.remove('playing'); };
        } else {
            // One Shot Flash
            btn.classList.add('playing');
            setTimeout(()=> btn.classList.remove('playing'), 150);
        }
    }

    /* --- Pad Menu --- */
    const padMenu = $('padMenu');
    function showPadMenu(e, idx) {
        activePadIndex = idx;
        padMenu.style.left = e.pageX + 'px';
        padMenu.style.top = e.pageY + 'px';
        padMenu.style.display = 'block';
    }
    
    document.addEventListener('click', (e)=>{
        if(!e.target.closest('#padMenu') && !e.target.closest('.sample-pad')) {
            padMenu.style.display = 'none';
        }
    });

    window.handleMenu = (action) => {
        padMenu.style.display = 'none';
        if(activePadIndex === -1) return;
        const p = samplerPads[activePadIndex];
        const btn = $(`pad${activePadIndex}`);

        if(action === 'load') {
            $('sampleInput').click();
        } else if(action === 'rec') {
            p.mode = 'record';
            btn.classList.add('armed');
            btn.querySelector('span').innerText = "ARMED (TAP)";
        } else {
            p.mode = action; // oneshot, toggle, loop
            btn.classList.remove('armed');
        }
    };

    $('sampleInput').onchange = (e) => {
        if(e.target.files.length && activePadIndex !== -1) {
            loadSampleFile(e.target.files[0], activePadIndex);
        }
        $('sampleInput').value = '';
    }

    async function loadSampleFile(file, idx) {
        if(!audioCtx) initAudio();
        try {
            const ab = await file.arrayBuffer();
            const buf = await audioCtx.decodeAudioData(ab);
            const p = samplerPads[idx];
            p.buffer = buf;
            p.name = file.name.substring(0,8);
            p.mode = 'oneshot';
            
            const btn = $(`pad${idx}`);
            btn.classList.add('loaded');
            btn.classList.remove('armed');
            btn.querySelector('span').innerText = p.name;
        } catch(e) { console.error(e); }
    }

    /* --- Pad Recording (Persistent Stream) --- */
    let globalMicStream = null;

    async function getMicStream() {
        if (globalMicStream && globalMicStream.active) return globalMicStream;
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        globalMicStream = stream;
        return stream;
    }

    async function togglePadRecording(idx) {
        if(padRecorders[idx]) {
            // STOP
            padRecorders[idx].stop();
            delete padRecorders[idx];
            const btn = $(`pad${idx}`);
            btn.classList.remove('recording');
            btn.classList.remove('armed');
            samplerPads[idx].mode = 'oneshot'; // Reset to play
        } else {
            // START
            try {
                const stream = await getMicStream();
                const rec = new MediaRecorder(stream);
                const chunks = [];
                rec.ondataavailable = e => chunks.push(e.data);
                rec.onstop = async () => {
                    const blob = new Blob(chunks, {type:'audio/webm'});
                    const ab = await blob.arrayBuffer();
                    const buf = await audioCtx.decodeAudioData(ab);
                    samplerPads[idx].buffer = buf;
                    samplerPads[idx].name = "REC";
                    const btn = $(`pad${idx}`);
                    btn.classList.add('loaded');
                    btn.querySelector('span').innerText = "REC";
                };
                rec.start();
                padRecorders[idx] = rec;
                $(`pad${idx}`).classList.add('recording');
            } catch(e) { alert("Mic Error"); }
        }
    }

    /* --- KIT SAVING / LOADING --- */
    
    // Helpers needed for saving
    function floatTo16BitPCM(output, offset, input) {
        for (let i = 0; i < input.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, input[i]));
            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
    }
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
    function encodeWAV(samples, sampleRate) {
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, samples.length * 2, true);
        floatTo16BitPCM(view, 44, samples);
        return buffer;
    }
    
    window.saveKit = async () => {
        const kitData = { pads: [] };
        
        for(let i=0; i<16; i++) {
            const p = samplerPads[i];
            let b64 = null;
            if(p.buffer) {
                // Encode AudioBuffer to WAV Base64
                const chanData = p.buffer.getChannelData(0); // Mono for simplicity/speed
                const wavBuf = encodeWAV(chanData, p.buffer.sampleRate);
                // Convert ArrayBuffer to Base64
                let binary = '';
                const bytes = new Uint8Array(wavBuf);
                const len = bytes.byteLength;
                for (let j = 0; j < len; j++) {
                    binary += String.fromCharCode(bytes[j]);
                }
                b64 = window.btoa(binary);
            }
            
            kitData.pads.push({
                name: p.name,
                mode: p.mode,
                audioData: b64
            });
        }
        
        const blob = new Blob([JSON.stringify(kitData)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ScratcherPro_Kit.json';
        a.click();
    };
    
    $('kitInput').onchange = async (e) => {
        const f = e.target.files[0];
        if(!f) return;
        const text = await f.text();
        try {
            const data = JSON.parse(text);
            if(data.pads) {
                for(let i=0; i<16; i++) {
                    if(i >= data.pads.length) break;
                    const src = data.pads[i];
                    const dst = samplerPads[i];
                    
                    dst.name = src.name;
                    dst.mode = src.mode;
                    const btn = $(`pad${i}`);
                    btn.querySelector('span').innerText = dst.name;
                    
                    if(src.audioData) {
                        const bin = window.atob(src.audioData);
                        const len = bin.length;
                        const bytes = new Uint8Array(len);
                        for (let j = 0; j < len; j++) bytes[j] = bin.charCodeAt(j);
                        const buf = await audioCtx.decodeAudioData(bytes.buffer);
                        dst.buffer = buf;
                        btn.classList.add('loaded');
                    } else {
                        dst.buffer = null;
                        btn.classList.remove('loaded');
                    }
                }
                alert("Kit Loaded Successfully!");
            }
        } catch(err) { console.error(err); alert("Invalid Kit File"); }
        $('kitInput').value = '';
    };

    function initDeckChain(d){
        d.gain = audioCtx.createGain();
        d.gain.gain.value = 0.8;
        d.analyser = audioCtx.createAnalyser();
        d.analyser.smoothingTimeConstant = 0.8;
        d.analyser.fftSize = 64;

        d.eq.low = audioCtx.createBiquadFilter(); d.eq.low.type = 'lowshelf'; d.eq.low.frequency.value = 320;
        d.eq.mid = audioCtx.createBiquadFilter(); d.eq.mid.type = 'peaking'; d.eq.mid.frequency.value = 1000;
        d.eq.high = audioCtx.createBiquadFilter(); d.eq.high.type = 'highshelf'; d.eq.high.frequency.value = 3200;

        d.eq.low.connect(d.eq.mid);
        d.eq.mid.connect(d.eq.high);
        d.eq.high.connect(d.gain);
        d.gain.connect(d.analyser);
        
        d.analyser.connect(masterGain); 
        d.analyser.connect(fxDriveNode);
        d.analyser.connect(fxFilterNode);
        d.analyser.connect(fxReverbNode);
        d.analyser.connect(fxDelayNode);
    }

    /* --------- FILE LOADING --------- */
    $('loadFilesBtn').onclick = () => $('musicFiles').click();
    $('addFilesBtn').onclick = () => $('filePicker').click();
    $('musicFiles').onchange = (e) => loadFiles(e.target.files);
    $('filePicker').onchange = (e) => loadFiles(e.target.files);

    async function loadFiles(list) {
        if(!audioCtx) initAudio();
        $('loadingStatus').innerText = "LOADING...";
        
        for(let i=0; i<list.length; i++) {
            let f = list[i];
            if(f.type.startsWith('audio') || f.name.match(/\.(mp3|wav|ogg|m4a)$/i)) {
                try {
                    const ab = await f.arrayBuffer();
                    const buf = await audioCtx.decodeAudioData(ab);
                    const bpm = 120 + Math.floor(Math.random()*10);
                    TRACKS.push({ name:f.name, buffer:buf, bpm:bpm });
                } catch(e) { console.log(e); }
            }
        }
        
        // UPDATE UI IMMEDIATELY
        ['A','B'].forEach(id => {
            const s = $(`trackSelect${id}`);
            if(TRACKS.length > 0) {
               s.innerHTML = '<option value="-1">Select Track</option>'; 
               TRACKS.forEach((t, idx) => {
                   s.innerHTML += `<option value="${idx}">${t.name}</option>`;
               });
            }
        });
        
        $('loadingStatus').innerText = `READY (${TRACKS.length})`;
    }

    ['A','B'].forEach(id => {
        $(`trackSelect${id}`).onchange = (e) => loadDeck(id, e.target.value);
    });

    function loadDeck(id, idx) {
        if(idx<0) return;
        const d = decks[id];
        const t = TRACKS[idx];
        stopDeck(id);
        d.buffer = t.buffer;
        d.playbackPos = 0;
        d.detectedBPM = t.bpm;
        d.bpm = t.bpm;
        d.hotCues = [null,null,null,null];
        d.loopIn = -1; d.loopOut = -1; d.isLooping = false;
        
        $(`bpm${id}`).innerText = d.bpm.toFixed(1);
        $(`status${id}`).innerText = t.name;
        
        for(let i=1;i<=4;i++) $(`hc${id}${i}`).classList.remove('set');
    }

    /* --------- PLAYBACK & PHYSICS --------- */
    function playDeck(id) {
        const d = decks[id];
        if(!d.buffer) return;
        if(d.source) stopDeck(id, false);

        d.source = audioCtx.createBufferSource();
        d.source.buffer = d.buffer;
        d.source.playbackRate.value = d.speed;
        d.source.connect(d.eq.low);
        d.source.start(0, d.playbackPos);
        d.lastTime = audioCtx.currentTime;
        d.isPlaying = true;
        
        $(`play${id}`).classList.add('playing');
    }

    function stopDeck(id, reset=false) {
        const d = decks[id];
        if(d.source) {
            try{ d.source.stop(); }catch(e){}
            d.source.disconnect();
            d.source = null;
        }
        d.isPlaying = false;
        if(!d.isDragging) $(`play${id}`).classList.remove('playing');
        if(reset) { d.playbackPos=0; $(`play${id}`).classList.remove('playing'); }
    }

    function updateLoop() {
        updateDeckLogic(decks.A);
        updateDeckLogic(decks.B);
        drawWaveform('A');
        drawWaveform('B');
        updateVUs();
        if(isRecording) updateRecTimer();
        requestAnimationFrame(updateLoop);
    }

    function updateDeckLogic(d) {
        if(d.isPlaying) {
            const now = audioCtx.currentTime;
            const dt = now - d.lastTime;
            d.lastTime = now;
            d.playbackPos += dt * d.speed;
            
            if(d.isLooping && d.loopOut !== -1 && d.playbackPos >= d.loopOut) {
                d.playbackPos = d.loopIn;
                stopDeck(d.id, false);
                playDeck(d.id);
            }
            if(d.playbackPos >= d.buffer.duration) {
                d.playbackPos = d.buffer.duration;
                stopDeck(d.id);
            }
        }
        
        if(!d.isDragging && d.buffer) {
            const deg = (d.playbackPos / 1.8) * 360;
            d.angle = deg;
            $(`record${d.id}`).style.transform = `rotate(${d.angle}deg)`;
        }
    }

    /* --------- TRUE MULTI-TOUCH SCRATCH --------- */
    function getPointerAngle(el, cx, cy) {
        const rect = el.getBoundingClientRect();
        const centerx = rect.left + rect.width/2;
        const centery = rect.top + rect.height/2;
        return Math.atan2(cy - centery, cx - centerx) * 180 / Math.PI;
    }
    
    function shortestDelta(a, b){
        let d = b - a;
        while (d > 180) d -= 360;
        while (d < -180) d += 360;
        return d;
    }

    ['A','B'].forEach(id => {
        const rec = $(`record${id}`);
        const d = decks[id];
        
        rec.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if(!d.buffer) return;
            d.isDragging = true;
            d.wasPlaying = d.isPlaying; 
            if(d.isPlaying) { stopDeck(id, false); $(`play${id}`).classList.add('playing'); }
            d.startAngle = getPointerAngle(rec, e.clientX, e.clientY);
            d.baseAngle = d.angle;
            d.accumAngle = 0;
            d.startPlaybackPos = d.playbackPos;
        });

        window.addEventListener('mousemove', (e) => {
            if(!d.isDragging || d.touchId !== null) return; 
            e.preventDefault();
            const cur = getPointerAngle(rec, e.clientX, e.clientY);
            const delta = shortestDelta(d.startAngle, cur);
            d.accumAngle += delta;
            d.startAngle = cur;
            d.angle = d.baseAngle + d.accumAngle;
            rec.style.transform = `rotate(${d.angle}deg)`;
            const timeDelta = (d.accumAngle / 360) * 1.8;
            d.playbackPos = Math.max(0, Math.min(d.buffer.duration, d.startPlaybackPos + timeDelta));
        });

        window.addEventListener('mouseup', (e) => {
            if(!d.isDragging || d.touchId !== null) return;
            d.isDragging = false;
            if(d.wasPlaying) playDeck(id);
            else $(`play${id}`).classList.remove('playing');
        });

        rec.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(!d.buffer) return;
            const t = e.changedTouches[0];
            d.touchId = t.identifier;
            d.isDragging = true;
            d.wasPlaying = d.isPlaying; 
            if(d.isPlaying) { stopDeck(id, false); $(`play${id}`).classList.add('playing'); }
            d.startAngle = getPointerAngle(rec, t.clientX, t.clientY);
            d.baseAngle = d.angle;
            d.accumAngle = 0;
            d.startPlaybackPos = d.playbackPos;
        }, {passive:false});

        window.addEventListener('touchmove', (e) => {
            if(!d.isDragging || d.touchId === null) return;
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === d.touchId) {
                    e.preventDefault();
                    const t = e.changedTouches[i];
                    const cur = getPointerAngle(rec, t.clientX, t.clientY);
                    const delta = shortestDelta(d.startAngle, cur);
                    d.accumAngle += delta;
                    d.startAngle = cur;
                    d.angle = d.baseAngle + d.accumAngle;
                    rec.style.transform = `rotate(${d.angle}deg)`;
                    const timeDelta = (d.accumAngle / 360) * 1.8;
                    d.playbackPos = Math.max(0, Math.min(d.buffer.duration, d.startPlaybackPos + timeDelta));
                    break;
                }
            }
        }, {passive:false});

        window.addEventListener('touchend', (e) => {
            if(!d.isDragging || d.touchId === null) return;
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === d.touchId) {
                    d.isDragging = false;
                    d.touchId = null;
                    if(d.wasPlaying) playDeck(id);
                    else $(`play${id}`).classList.remove('playing');
                    break;
                }
            }
        });
    });

    /* --------- STYLUS --------- */
    (function(){
      var SAFE_GAP_PX = 14;
      function computeTravelPx(record){
        var w = record.clientWidth;
        var radius = w / 2;
        var labelR = (radius * 0.35); 
        return Math.max(10, Math.floor((radius - labelR) - SAFE_GAP_PX));
      }

      function createStylus(record){
        var plate = record.parentElement;
        if (!plate) return;
        var slider = document.createElement('div');
        slider.className = 'stylus-slider';
        var hit = document.createElement('div');
        hit.className = 'stylus-hitbox';
        var handle = document.createElement('div');
        handle.className = 'stylus-handle';
        hit.appendChild(handle);
        slider.appendChild(hit);
        plate.appendChild(slider);

        var dragging = false;
        var deckId = record.id.replace('record','');
        var d = decks[deckId];

        function render(){
          if(!d.buffer) return;
          var w = slider.clientWidth;
          var hw = 12; 
          var pct = d.playbackPos / d.buffer.duration;
          var x = (1 - pct) * w - hw; 
          hit.style.left = Math.max(-hw, Math.min(w - hw, x)) + 'px';
        }

        setInterval(render, 30);

        const onStart = (e) => {
            e.preventDefault(); dragging = true;
            if(d.isPlaying) { stopDeck(deckId, false); d.wasPlayingStylus = true; } else { d.wasPlayingStylus = false; }
        };
        const onMove = (e) => {
            if(!dragging || !d.buffer) return;
            const rect = slider.getBoundingClientRect();
            let cx = e.touches ? e.touches[0].clientX : e.clientX;
            let x = Math.max(0, Math.min(cx - rect.left, rect.width));
            let val = 1 - (x / rect.width);
            d.playbackPos = val * d.buffer.duration;
            render();
        };
        const onEnd = () => {
            if(!dragging) return;
            dragging = false;
            if(d.wasPlayingStylus) playDeck(deckId);
        };

        hit.addEventListener('mousedown', onStart);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onEnd);
        hit.addEventListener('touchstart', onStart, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', onEnd);
        
        setTimeout(()=>{ slider.style.width = computeTravelPx(record)+'px'; }, 100);
      }
      setTimeout(()=>{ ['A','B'].forEach(id => createStylus($(`record${id}`))); }, 500);
    })();

    /* --------- CONTROLS WIRING --------- */
    ['A','B'].forEach(id => {
        $(`play${id}`).onclick = () => { if(decks[id].isPlaying) stopDeck(id); else playDeck(id); };
        $(`stop${id}`).onclick = () => stopDeck(id, true);
        $(`cue${id}`).onclick = () => { stopDeck(id); decks[id].playbackPos=0; };
        
        $(`pitch${id}`).oninput = (e) => {
            decks[id].speed = parseFloat(e.target.value);
            if(decks[id].source) decks[id].source.playbackRate.value = decks[id].speed;
            decks[id].bpm = decks[id].detectedBPM * decks[id].speed;
            $(`bpm${id}`).innerText = decks[id].bpm.toFixed(1);
        };

        $(`sync${id}`).onclick = () => {
            const other = id==='A' ? decks.B : decks.A;
            if(!other.buffer) return;
            const ratio = other.bpm / decks[id].detectedBPM;
            decks[id].speed = ratio;
            $(`pitch${id}`).value = ratio;
            decks[id].bpm = other.bpm;
            $(`bpm${id}`).innerText = decks[id].bpm.toFixed(1);
            if(decks[id].source) decks[id].source.playbackRate.value = ratio;
        };

        $(`loopIn${id}`).onclick = () => { decks[id].loopIn = decks[id].playbackPos; };
        $(`loopOut${id}`).onclick = () => { decks[id].loopOut = decks[id].playbackPos; decks[id].isLooping=true; };
        $(`loopExit${id}`).onclick = () => { decks[id].isLooping=false; };
        $(`loop4${id}`).onclick = () => { if(!decks[id].buffer)return; decks[id].loopIn=decks[id].playbackPos; decks[id].loopOut=decks[id].loopIn + (60/decks[id].bpm)*4; decks[id].isLooping=true; };
        $(`loop8${id}`).onclick = () => { if(!decks[id].buffer)return; decks[id].loopIn=decks[id].playbackPos; decks[id].loopOut=decks[id].loopIn + (60/decks[id].bpm)*8; decks[id].isLooping=true; };

        // PADS (FIXED JUMP)
        for(let i=1; i<=4; i++){
            const btn = $(`hc${id}${i}`);
            btn.onclick = (e) => {
                const d = decks[id];
                const idx = i-1;
                if(e.shiftKey) { d.hotCues[idx]=null; btn.classList.remove('set'); }
                else {
                    if(d.hotCues[idx]===null) { d.hotCues[idx]=d.playbackPos; btn.classList.add('set'); }
                    else { 
                        d.playbackPos = d.hotCues[idx];
                        if(d.isPlaying) {
                            stopDeck(id, false);
                            playDeck(id);
                        }
                    }
                }
            };
            btn.oncontextmenu = (e) => { e.preventDefault(); decks[id].hotCues[i-1]=null; btn.classList.remove('set'); };
        }

        $(`vol${id}`).oninput = (e) => decks[id].gain.gain.value = e.target.value;
        $(`eqLow${id}`).oninput = (e) => decks[id].eq.low.gain.value = e.target.value;
        $(`eqMid${id}`).oninput = (e) => decks[id].eq.mid.gain.value = e.target.value;
        $(`eqHigh${id}`).oninput = (e) => decks[id].eq.high.gain.value = e.target.value;
    });

    // MASTER & FX
    $('masterVol').oninput = (e) => {
        if(masterGain) masterGain.gain.value = e.target.value;
    };
    
    $('fxReverb').oninput = (e) => { if(fxReverbGain) fxReverbGain.gain.value = e.target.value; };
    $('fxDelay').oninput = (e) => { if(fxDelayGain) fxDelayGain.gain.value = e.target.value; };
    
    $('fxDrive').oninput = (e) => {
        if(fxDriveNode) fxDriveNode.curve = makeDistortionCurve(e.target.value * 100);
    };
    $('masterFilterFreq').oninput = (e) => {
        if(fxFilterNode) fxFilterNode.frequency.value = e.target.value;
    };

    /* --------- WAVEFORMS --------- */
    function drawWaveform(id) {
        const d = decks[id];
        if(!d.buffer) return;
        const cvs = $(`wave${id}`);
        const ctx = cvs.getContext('2d');
        if(cvs.width !== cvs.clientWidth) { cvs.width=cvs.clientWidth; cvs.height=cvs.clientHeight; }
        
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,cvs.width,cvs.height);
        
        const data = d.buffer.getChannelData(0);
        const zoom = 500; 
        const mid = cvs.height/2;
        const ctrSample = Math.floor(d.playbackPos * d.buffer.sampleRate);
        const halfW = cvs.width/2;
        
        ctx.beginPath();
        ctx.strokeStyle = id==='A' ? '#f43f5e' : '#0ea5e9';
        for(let x=0; x<cvs.width; x+=2) {
            const idx = ctrSample - (halfW - x)*zoom;
            if(idx>=0 && idx<data.length) {
                const v = data[Math.floor(idx)] * (mid*0.9);
                ctx.moveTo(x, mid-v);
                ctx.lineTo(x, mid+v);
            }
        }
        ctx.stroke();
    }

    /* --------- VU METERS (LOG SCALE) --------- */
    function updateVUs() {
        ['A','B'].forEach(id => {
            const d = decks[id];
            if(!d.analyser) return;
            const arr = new Uint8Array(d.analyser.frequencyBinCount);
            d.analyser.getByteTimeDomainData(arr);
            let sum=0; for(let x of arr) sum += (x-128)*(x-128);
            const rms = Math.sqrt(sum/arr.length);
            const db = 20 * Math.log10(rms || 0.00001); 
            const h = Math.max(0, (db + 60) / 60);
            updateStrip($(`vu${id}`), h);
        });
        
        if(masterAnalyser) {
            const arr = new Uint8Array(masterAnalyser.frequencyBinCount);
            masterAnalyser.getByteTimeDomainData(arr);
            let sum=0; for(let x of arr) sum += (x-128)*(x-128);
            const rms = Math.sqrt(sum/arr.length);
            const db = 20 * Math.log10(rms || 0.00001);
            const h = Math.max(0, (db + 60) / 60);
            updateStrip($('vuMasterL'), h);
            updateStrip($('vuMasterR'), h);
        }
    }
    
    function updateStrip(el, h) {
        if(el.children.length===0) {
            for(let i=0;i<20;i++) {
                let d = document.createElement('div');
                d.className = el.id.includes('Master') ? 'm-seg' : 'deck-seg';
                if(el.id.includes('Master')) {
                    if(i>13) d.classList.add('mid');
                    if(i>17) d.classList.add('red');
                } else {
                    if(i>13) d.classList.add('mid');
                    if(i>17) d.classList.add('red');
                }
                el.appendChild(d);
            }
        }
        const on = Math.floor(h*20);
        for(let i=0;i<20;i++) {
            if(i<on) el.children[i].classList.add('on');
            else el.children[i].classList.remove('on');
        }
    }

    /* --------- RECORDER --------- */
    let isRecording = false;
    $('recBtn').onclick = () => {
        if(!isRecording) {
            recChunks = [];
            mediaRecorder = new MediaRecorder(recDest.stream);
            mediaRecorder.ondataavailable = e => recChunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(recChunks, {'type':'audio/wav'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href=url; a.download='mix.wav'; a.click();
            };
            mediaRecorder.start();
            isRecording=true;
            recStartTime = Date.now();
            $('recBtn').classList.add('active');
            $('recTimer').style.visibility='visible';
        } else {
            mediaRecorder.stop();
            isRecording=false;
            $('recBtn').classList.remove('active');
            $('recTimer').style.visibility='hidden';
        }
    };
    function updateRecTimer(){
        const s = Math.floor((Date.now()-recStartTime)/1000);
        const m = Math.floor(s/60).toString().padStart(2,'0');
        const sc = (s%60).toString().padStart(2,'0');
        $('recTimer').innerText = `${m}:${sc}`;
    }

    /* --------- MIDI LEARN --------- */
    let midiAccess=null; let midiMode=false; let midiMap={}; let pendingEl=null;
    $('midiBtn').onclick = async () => {
        if(!midiAccess) {
            try { midiAccess = await navigator.requestMIDIAccess(); 
                  for(let i of midiAccess.inputs.values()) i.onmidimessage=onMidiMsg; 
            } catch(e){ alert("MIDI Error"); return; }
        }
        midiMode = !midiMode;
        $('midiOverlay').style.display = midiMode ? 'flex' : 'none';
        $('midiBtn').classList.toggle('active', midiMode);
    };
    $('closeMidiBtn').onclick = () => { midiMode=false; $('midiOverlay').style.display='none'; $('midiBtn').classList.remove('active'); };

    function onMidiMsg(m) {
        const [s,d1,d2] = m.data;
        const key = `${s}_${d1}`;
        if(midiMode && pendingEl) {
            midiMap[key] = pendingEl;
            alert("Mapped!");
            pendingEl = null;
        } else if(midiMap[key]) {
            const el = $(midiMap[key]);
            if(el.type==='range') {
                const min = parseFloat(el.min), max = parseFloat(el.max);
                el.value = (d2/127)*(max-min) + min;
                el.dispatchEvent(new Event('input'));
            } else if(d2>64) el.click();
        }
    }
    document.querySelectorAll('button, input').forEach(el => {
        el.addEventListener('click', (e)=>{
            if(midiMode) { e.preventDefault(); e.stopPropagation(); pendingEl=el.id; el.classList.add('midi-target'); setTimeout(()=>el.classList.remove('midi-target'),500); }
        });
    });

    /* --------- CROSSFADER --------- */
    const xTouch = $('xfTouch'); 
    const xHandle = $('crossfaderHandle');
    const xRail = $('crossfaderRail');
    let xTouchId = null; 
    let xMouseDrag = false;

    function updateCrossfader(clientX) {
        const r = xRail.getBoundingClientRect();
        let x = Math.max(0, Math.min(clientX - r.left, r.width));
        let pct = x / r.width;
        xHandle.style.left = (pct*100)+'%';
        
        const gA = Math.cos(pct * 0.5 * Math.PI);
        const gB = Math.cos((1-pct) * 0.5 * Math.PI);
        if(decks.A.gain) decks.A.gain.gain.value = $('volA').value * gA;
        if(decks.B.gain) decks.B.gain.gain.value = $('volB').value * gB;
    }

    xTouch.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        const t = e.changedTouches[0];
        xTouchId = t.identifier;
        updateCrossfader(t.clientX);
    }, {passive:false});
    
    window.addEventListener('touchmove', (e)=>{
        if(xTouchId === null) return;
        for(let i=0; i<e.changedTouches.length; i++){
            if(e.changedTouches[i].identifier === xTouchId){
                e.preventDefault();
                updateCrossfader(e.changedTouches[i].clientX);
            }
        }
    }, {passive:false});
    
    window.addEventListener('touchend', (e)=>{
        if(xTouchId === null) return;
        for(let i=0; i<e.changedTouches.length; i++){
            if(e.changedTouches[i].identifier === xTouchId){
                xTouchId = null;
            }
        }
    });

    xTouch.addEventListener('mousedown', (e)=>{ xMouseDrag=true; updateCrossfader(e.clientX); });
    window.addEventListener('mousemove', (e)=>{ if(xMouseDrag) updateCrossfader(e.clientX); });
    window.addEventListener('mouseup', ()=>{ xMouseDrag=false; });

  </script>
</body>
</html>
